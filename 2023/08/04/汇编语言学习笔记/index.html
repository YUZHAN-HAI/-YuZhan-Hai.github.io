<!DOCTYPE html>
<html lang="en">
    <head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/#5.7.8'>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="Volantis" content="5.7.8">
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
  <link rel="canonical" href="http://example.com/2023/08/04/汇编语言学习笔记/"/>
  <!-- 渲染优化 -->
    <meta http-equiv='x-dns-prefetch-control' content='on' />
      <link rel='dns-prefetch' href='https://unpkg.com'>
      <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Content-Security-Policy" content=" default-src 'self' https:; block-all-mixed-content; base-uri 'self' https:; form-action 'self' https:; worker-src 'self' https:; connect-src 'self' https: *; img-src 'self' data: https: *; media-src 'self' https: *; font-src 'self' data: https: *; frame-src 'self' https: *; manifest-src 'self' https: *; child-src https:; script-src 'self' https: 'unsafe-inline' *; style-src 'self' https: 'unsafe-inline' *; ">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta content="black-translucent" name="apple-mobile-web-app-status-bar-style">
  <meta content="telephone=no" name="format-detection">
  <!-- import head_begin begin -->
  <!-- import head_begin end -->
  <!-- Custom Files headBegin begin-->
  
  <!-- Custom Files headBegin end-->
  <link rel="preload" href="/css/style.css" as="style">
  <link rel="preload" href="https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/VarelaRound/VarelaRound-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
<link rel="preload" href="https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <!-- feed -->
  <!-- 页面元数据 -->
  <title>Hexo</title>
  <meta name="keywords" content="null">
  <meta desc name="description" content="wode - John Doe - Hexo">
  
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2023/08/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="目录第一章 基础知识第二章 寄存器（CPU工作原理）第三章 寄存器（内存访问）第四章 第一个程序第五章 [BX]和loop指令第六章 包含多个段的程序第七章 更灵活定位内存地址第八章 数据处理的两个基本问题第九章 转移指令的原理第十章 call和ret指令第十一章 标志寄存器第十二章 内中断第十三章 int指令第十四章 端口第十五章 外中断第十六章 直接定址表第十七章 使用BIOS进入键盘输入和磁">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
<meta property="article:published_time" content="2023-08-04T14:38:27.176Z">
<meta property="article:modified_time" content="2023-08-04T15:03:02.361Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
  <style>
    /* 首屏样式 */
    #safearea {
  display: none;
}
:root {
  --color-site-body: #f4f4f4;
  --color-site-bg: #f4f4f4;
  --color-site-inner: #fff;
  --color-site-footer: #666;
  --color-card: #fff;
  --color-text: #444;
  --color-block: #f6f6f6;
  --color-inlinecode: #c74f00;
  --color-codeblock: #fff7ea;
  --color-h1: #3a3a3a;
  --color-h2: #3a3a3a;
  --color-h3: #333;
  --color-h4: #444;
  --color-h5: #555;
  --color-h6: #666;
  --color-p: #444;
  --color-list: #666;
  --color-list-hl: #30ad91;
  --color-meta: #888;
  --color-read-bkg: #e0d8c8;
  --color-read-post: #f8f1e2;
  --color-copyright-bkg: #f5f5f5;
}
* {
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  outline: none;
  margin: 0;
  padding: 0;
}
*::-webkit-scrollbar {
  height: 4px;
  width: 4px;
}
*::-webkit-scrollbar-track-piece {
  background: transparent;
}
*::-webkit-scrollbar-thumb {
  background: #3dd9b6;
  cursor: pointer;
  border-radius: 2px;
  -webkit-border-radius: 2px;
}
*::-webkit-scrollbar-thumb:hover {
  background: #ff5722;
}
html {
  color: var(--color-text);
  width: 100%;
  height: 100%;
  font-family: UbuntuMono, "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif;
  font-size: 16px;
}
html >::-webkit-scrollbar {
  height: 4px;
  width: 4px;
}
html >::-webkit-scrollbar-track-piece {
  background: transparent;
}
html >::-webkit-scrollbar-thumb {
  background: #3dd9b6;
  cursor: pointer;
  border-radius: 2px;
  -webkit-border-radius: 2px;
}
html >::-webkit-scrollbar-thumb:hover {
  background: #ff5722;
}
body {
  background-color: var(--color-site-body);
  text-rendering: optimizelegibility;
  -webkit-tap-highlight-color: rgba(0,0,0,0);
  line-height: 1.6;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
}
body.modal-active {
  overflow: hidden;
}
@media screen and (max-width: 680px) {
  body.modal-active {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
}
a {
  color: #2092ec;
  cursor: pointer;
  text-decoration: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
a:hover {
  color: #ff5722;
}
a:active,
a:hover {
  outline: 0;
}
ul,
ol {
  padding-left: 0;
}
ul li,
ol li {
  list-style: none;
}
header {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
img {
  border: 0;
  background: none;
  max-width: 100%;
}
svg:not(:root) {
  overflow: hidden;
}
hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  height: 0;
  border: 0;
  border-radius: 1px;
  -webkit-border-radius: 1px;
  border-bottom: 1px solid rgba(68,68,68,0.1);
}
button,
input {
  color: inherit;
  font: inherit;
  margin: 0;
}
button {
  overflow: visible;
  text-transform: none;
  -webkit-appearance: button;
  cursor: pointer;
}
@supports (backdrop-filter: blur(20px)) {
  .blur {
    background: rgba(255,255,255,0.9) !important;
    backdrop-filter: saturate(200%) blur(20px);
  }
}
.shadow {
  box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
}
.shadow.floatable {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.shadow.floatable:hover {
  box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1);
}
#l_cover {
  min-height: 64px;
}
.cover-wrapper {
  top: 0;
  left: 0;
  max-width: 100%;
  height: 100vh;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  align-self: center;
  align-content: center;
  color: var(--color-site-inner);
  padding: 0 16px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  position: relative;
  overflow: hidden;
  margin-bottom: -100px;
}
.cover-wrapper .cover-bg {
  position: absolute;
  width: 100%;
  height: 100%;
  background-position: center;
  background-size: cover;
  -webkit-background-size: cover;
  -moz-background-size: cover;
}
.cover-wrapper .cover-bg.lazyload:not(.loaded) {
  opacity: 0;
  -webkit-opacity: 0;
  -moz-opacity: 0;
}
.cover-wrapper .cover-bg.lazyload.loaded {
  animation-delay: 0s;
  animation-duration: 0.5s;
  animation-fill-mode: forwards;
  animation-timing-function: ease-out;
  animation-name: fadeIn;
}
@-moz-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.cover-wrapper .cover-body {
  z-index: 1;
  position: relative;
  width: 100%;
  height: 100%;
}
.cover-wrapper#full {
  height: calc(100vh + 100px);
  padding-bottom: 100px;
}
.cover-wrapper#half {
  max-height: 640px;
  min-height: 400px;
  height: calc(36vh - 64px + 200px);
}
.cover-wrapper #scroll-down {
  width: 100%;
  height: 64px;
  position: absolute;
  bottom: 100px;
  text-align: center;
  cursor: pointer;
}
.cover-wrapper #scroll-down .scroll-down-effects {
  color: #fff;
  font-size: 24px;
  line-height: 64px;
  position: absolute;
  width: 24px;
  left: calc(50% - 12px);
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
  animation: scroll-down-effect 1.5s infinite;
  -webkit-animation: scroll-down-effect 1.5s infinite;
  -khtml-animation: scroll-down-effect 1.5s infinite;
  -moz-animation: scroll-down-effect 1.5s infinite;
  -o-animation: scroll-down-effect 1.5s infinite;
  -ms-animation: scroll-down-effect 1.5s infinite;
}
@-moz-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.cover-wrapper .cover-body {
  margin-top: 64px;
  margin-bottom: 100px;
}
.cover-wrapper .cover-body,
.cover-wrapper .cover-body .top,
.cover-wrapper .cover-body .bottom {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  max-width: 100%;
}
.cover-wrapper .cover-body .bottom {
  margin-top: 32px;
}
.cover-wrapper .cover-body .title {
  font-family: "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Helvetica, monospace;
  font-size: 3.125rem;
  line-height: 1.2;
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
.cover-wrapper .cover-body .subtitle {
  font-size: 20px;
}
.cover-wrapper .cover-body .logo {
  max-height: 120px;
  max-width: calc(100% - 4 * 16px);
}
@media screen and (min-height: 1024px) {
  .cover-wrapper .cover-body .title {
    font-size: 3rem;
  }
  .cover-wrapper .cover-body .subtitle {
    font-size: 1.05rem;
  }
  .cover-wrapper .cover-body .logo {
    max-height: 150px;
  }
}
.cover-wrapper .cover-body .m_search {
  position: relative;
  max-width: calc(100% - 16px);
  width: 320px;
  vertical-align: middle;
}
.cover-wrapper .cover-body .m_search .form {
  position: relative;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  width: 100%;
}
.cover-wrapper .cover-body .m_search .icon,
.cover-wrapper .cover-body .m_search .input {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.cover-wrapper .cover-body .m_search .icon {
  position: absolute;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  line-height: 2.5rem;
  width: 32px;
  top: 0;
  left: 5px;
  color: rgba(68,68,68,0.75);
}
.cover-wrapper .cover-body .m_search .input {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  height: 2.5rem;
  width: 100%;
  box-shadow: none;
  -webkit-box-shadow: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  font-size: 0.875rem;
  -webkit-appearance: none;
  padding-left: 36px;
  border-radius: 1.4rem;
  -webkit-border-radius: 1.4rem;
  background: rgba(255,255,255,0.6);
  backdrop-filter: blur(10px);
  border: none;
  color: var(--color-text);
}
@media screen and (max-width: 500px) {
  .cover-wrapper .cover-body .m_search .input {
    padding-left: 36px;
  }
}
.cover-wrapper .cover-body .m_search .input:hover {
  background: rgba(255,255,255,0.8);
}
.cover-wrapper .cover-body .m_search .input:focus {
  background: #fff;
}
.cover-wrapper .list-h {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: horizontal;
  -moz-box-orient: horizontal;
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
  flex-wrap: wrap;
  -webkit-flex-wrap: wrap;
  -khtml-flex-wrap: wrap;
  -moz-flex-wrap: wrap;
  -o-flex-wrap: wrap;
  -ms-flex-wrap: wrap;
  align-items: stretch;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.cover-wrapper .list-h a {
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  -webkit-flex: 1 0;
  -ms-flex: 1 0;
  flex: 1 0;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  font-weight: 600;
}
.cover-wrapper .list-h a img {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  border-radius: 2px;
  -webkit-border-radius: 2px;
  margin: 4px;
  min-width: 40px;
  max-width: 44px;
}
@media screen and (max-width: 768px) {
  .cover-wrapper .list-h a img {
    min-width: 36px;
    max-width: 40px;
  }
}
@media screen and (max-width: 500px) {
  .cover-wrapper .list-h a img {
    margin: 2px 4px;
    min-width: 32px;
    max-width: 36px;
  }
}
@media screen and (max-width: 375px) {
  .cover-wrapper .list-h a img {
    min-width: 28px;
    max-width: 32px;
  }
}
.cover-wrapper {
  max-width: 100%;
}
.cover-wrapper.search .bottom .menu {
  margin-top: 16px;
}
.cover-wrapper.search .bottom .menu .list-h a {
  white-space: nowrap;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: horizontal;
  -moz-box-orient: horizontal;
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
  align-items: baseline;
  padding: 2px;
  margin: 4px;
  color: var(--color-site-inner);
  opacity: 0.75;
  -webkit-opacity: 0.75;
  -moz-opacity: 0.75;
  text-shadow: 0 1px 2px rgba(0,0,0,0.05);
  border-bottom: 2px solid transparent;
}
.cover-wrapper.search .bottom .menu .list-h a i {
  margin-right: 4px;
}
.cover-wrapper.search .bottom .menu .list-h a p {
  font-size: 0.9375rem;
}
.cover-wrapper.search .bottom .menu .list-h a:hover,
.cover-wrapper.search .bottom .menu .list-h a.active,
.cover-wrapper.search .bottom .menu .list-h a:active {
  opacity: 1;
  -webkit-opacity: 1;
  -moz-opacity: 1;
  border-bottom: 2px solid var(--color-site-inner);
}
@font-face {
  font-family: 'UbuntuMono';
  src: url("https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf");
  font-weight: 'normal';
  font-style: 'normal';
  font-display: swap;
}
@font-face {
  font-family: 'Varela Round';
  src: url("https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/VarelaRound/VarelaRound-Regular.ttf");
  font-weight: 'normal';
  font-style: 'normal';
  font-display: swap;
}
.l_header {
  position: fixed;
  z-index: 1000;
  top: 0;
  width: 100%;
  height: 64px;
  background: var(--color-card);
  box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
}
.l_header.auto {
  transition: opacity 0.4s ease;
  -webkit-transition: opacity 0.4s ease;
  -khtml-transition: opacity 0.4s ease;
  -moz-transition: opacity 0.4s ease;
  -o-transition: opacity 0.4s ease;
  -ms-transition: opacity 0.4s ease;
  visibility: hidden;
}
.l_header.auto.show {
  opacity: 1 !important;
  -webkit-opacity: 1 !important;
  -moz-opacity: 1 !important;
  visibility: visible;
}
.l_header .container {
  margin-left: 16px;
  margin-right: 16px;
}
.l_header #wrapper {
  height: 100%;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.l_header #wrapper .nav-main,
.l_header #wrapper .nav-sub {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  justify-content: space-between;
  -webkit-justify-content: space-between;
  -khtml-justify-content: space-between;
  -moz-justify-content: space-between;
  -o-justify-content: space-between;
  -ms-justify-content: space-between;
  align-items: center;
}
.l_header #wrapper .nav-main {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.l_header #wrapper.sub .nav-main {
  transform: translateY(-64px);
  -webkit-transform: translateY(-64px);
  -khtml-transform: translateY(-64px);
  -moz-transform: translateY(-64px);
  -o-transform: translateY(-64px);
  -ms-transform: translateY(-64px);
}
.l_header #wrapper .nav-sub {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  opacity: 0;
  -webkit-opacity: 0;
  -moz-opacity: 0;
  height: 64px;
  width: calc(100% - 2 * 16px);
  position: absolute;
}
.l_header #wrapper .nav-sub ::-webkit-scrollbar {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
}
@media screen and (min-width: 2048px) {
  .l_header #wrapper .nav-sub {
    max-width: 55vw;
    margin: auto;
  }
}
.l_header #wrapper.sub .nav-sub {
  opacity: 1;
  -webkit-opacity: 1;
  -moz-opacity: 1;
}
.l_header #wrapper .title {
  position: relative;
  color: var(--color-text);
  padding-left: 24px;
  max-height: 64px;
}
.l_header #wrapper .nav-main .title {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex-shrink: 0;
  line-height: 64px;
  padding: 0 24px;
  font-size: 1.25rem;
  font-family: "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Helvetica, monospace;
}
.l_header #wrapper .nav-main .title img {
  height: 64px;
}
.l_header .nav-sub {
  max-width: 1080px;
  margin: auto;
}
.l_header .nav-sub .title {
  font-weight: bold;
  font-family: UbuntuMono, "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif;
  line-height: 1.2;
  max-height: 64px;
  white-space: normal;
  flex-shrink: 1;
}
.l_header .switcher {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  line-height: 64px;
  align-items: center;
}
.l_header .switcher .s-toc {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
}
@media screen and (max-width: 768px) {
  .l_header .switcher .s-toc {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: -ms-flexbox /* TWEENER - IE 10 */;
    display: -webkit-flex /* NEW - Chrome */;
    display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
    display: flex;
  }
}
.l_header .switcher >li {
  height: 48px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  margin: 2px;
}
@media screen and (max-width: 500px) {
  .l_header .switcher >li {
    margin: 0 1px;
    height: 48px;
  }
}
.l_header .switcher >li >a {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  align-items: center;
  width: 48px;
  height: 48px;
  padding: 0.85em 1.1em;
  border-radius: 100px;
  -webkit-border-radius: 100px;
  border: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  color: #3dd9b6;
}
.l_header .switcher >li >a:hover {
  border: none;
}
.l_header .switcher >li >a.active,
.l_header .switcher >li >a:active {
  border: none;
  background: var(--color-site-bg);
}
@media screen and (max-width: 500px) {
  .l_header .switcher >li >a {
    width: 36px;
    height: 48px;
  }
}
.l_header .nav-sub .switcher {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
}
.l_header .m_search {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  height: 64px;
  width: 240px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
@media screen and (max-width: 1024px) {
  .l_header .m_search {
    width: 44px;
    min-width: 44px;
  }
  .l_header .m_search input::placeholder {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
  }
  .l_header .m_search:hover {
    width: 240px;
  }
  .l_header .m_search:hover input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media screen and (min-width: 500px) {
  .l_header .m_search:hover .input {
    width: 100%;
  }
  .l_header .m_search:hover .input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media screen and (max-width: 500px) {
  .l_header .m_search {
    min-width: 0;
  }
  .l_header .m_search input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.l_header .m_search .form {
  position: relative;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  width: 100%;
  align-items: center;
}
.l_header .m_search .icon {
  position: absolute;
  width: 36px;
  left: 5px;
  color: var(--color-meta);
}
@media screen and (max-width: 500px) {
  .l_header .m_search .icon {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: none;
  }
}
.l_header .m_search .input {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  padding-top: 8px;
  padding-bottom: 8px;
  line-height: 1.3;
  width: 100%;
  color: var(--color-text);
  background: #fafafa;
  box-shadow: none;
  -webkit-box-shadow: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  padding-left: 40px;
  font-size: 0.875rem;
  border-radius: 8px;
  -webkit-border-radius: 8px;
  border: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
@media screen and (min-width: 500px) {
  .l_header .m_search .input:focus {
    box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1);
    -webkit-box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1);
  }
}
@media screen and (max-width: 500px) {
  .l_header .m_search .input {
    background: var(--color-block);
    padding-left: 8px;
    border: none;
  }
  .l_header .m_search .input:hover,
  .l_header .m_search .input:focus {
    border: none;
  }
}
@media (max-width: 500px) {
  .l_header .m_search {
    left: 0;
    width: 0;
    overflow: hidden;
    position: absolute;
    background: #fff;
    transition: all 0.28s ease;
    -webkit-transition: all 0.28s ease;
    -khtml-transition: all 0.28s ease;
    -moz-transition: all 0.28s ease;
    -o-transition: all 0.28s ease;
    -ms-transition: all 0.28s ease;
  }
  .l_header .m_search .input {
    border-radius: 32px;
    -webkit-border-radius: 32px;
    margin-left: 16px;
    padding-left: 16px;
  }
  .l_header.z_search-open .m_search {
    width: 100%;
  }
  .l_header.z_search-open .m_search .input {
    width: calc(100% - 120px);
  }
}
ul.m-pc >li>a {
  color: inherit;
  border-bottom: 2px solid transparent;
}
ul.m-pc >li>a:active,
ul.m-pc >li>a.active {
  border-bottom: 2px solid #3dd9b6;
}
ul.m-pc li:hover >ul.list-v,
ul.list-v li:hover >ul.list-v {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
ul.nav-list-h {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  align-items: stretch;
}
ul.nav-list-h>li {
  position: relative;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  height: 100%;
  line-height: 2.4;
  border-radius: 4px;
  -webkit-border-radius: 4px;
}
ul.nav-list-h>li >a {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-weight: 600;
}
ul.list-v {
  z-index: 1;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  position: absolute;
  background: var(--color-card);
  box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08);
  -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08);
  margin-top: -6px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  padding: 8px 0;
}
ul.list-v.show {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
ul.list-v hr {
  margin-top: 8px;
  margin-bottom: 8px;
}
ul.list-v >li {
  white-space: nowrap;
  word-break: keep-all;
}
ul.list-v >li.header {
  font-size: 0.78125rem;
  font-weight: bold;
  line-height: 2em;
  color: var(--color-meta);
  margin: 8px 16px 4px;
}
ul.list-v >li.header i {
  margin-right: 8px;
}
ul.list-v >li ul {
  margin-left: 0;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  margin-top: -40px;
}
ul.list-v .aplayer-container {
  min-height: 64px;
  padding: 6px 16px;
}
ul.list-v >li>a {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  color: var(--color-list);
  font-size: 0.875rem;
  font-weight: bold;
  line-height: 36px;
  padding: 0 20px 0 16px;
  text-overflow: ellipsis;
  margin: 0 4px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
}
@media screen and (max-width: 1024px) {
  ul.list-v >li>a {
    line-height: 40px;
  }
}
ul.list-v >li>a >i {
  margin-right: 8px;
}
ul.list-v >li>a:active,
ul.list-v >li>a.active {
  color: var(--color-list-hl);
}
ul.list-v >li>a:hover {
  color: var(--color-list-hl);
  background: var(--color-site-bg);
}
.l_header .menu >ul>li>a {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  padding: 0 8px;
}
.l_header .menu >ul>li>a >i {
  margin-right: 4px;
}
.l_header ul.nav-list-h>li {
  color: var(--color-list);
  line-height: 64px;
}
.l_header ul.nav-list-h>li >a {
  max-height: 64px;
  overflow: hidden;
  color: inherit;
}
.l_header ul.nav-list-h>li >a:active,
.l_header ul.nav-list-h>li >a.active {
  color: #3dd9b6;
}
.l_header ul.nav-list-h>li:hover>a {
  color: var(--color-list-hl);
}
.l_header ul.nav-list-h>li i.music {
  animation: rotate-effect 1.5s linear infinite;
  -webkit-animation: rotate-effect 1.5s linear infinite;
  -khtml-animation: rotate-effect 1.5s linear infinite;
  -moz-animation: rotate-effect 1.5s linear infinite;
  -o-animation: rotate-effect 1.5s linear infinite;
  -ms-animation: rotate-effect 1.5s linear infinite;
}
@-moz-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@-webkit-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@-o-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
.menu-phone li ul.list-v {
  right: calc(100% - 0.5 * 16px);
}
.menu-phone li ul.list-v ul {
  right: calc(100% - 0.5 * 16px);
}
#wrapper {
  max-width: 1080px;
  margin: auto;
}
@media screen and (min-width: 2048px) {
  #wrapper {
    max-width: 55vw;
  }
}
#wrapper .menu {
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  -webkit-flex: 1 1;
  -ms-flex: 1 1;
  flex: 1 1;
  margin: 0 16px 0 0;
}
#wrapper .menu .list-v ul {
  left: calc(100% - 0.5 * 16px);
}
.menu-phone {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  margin-top: 16px;
  right: 8px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.menu-phone ul {
  right: calc(100% - 0.5 * 16px);
}
@media screen and (max-width: 500px) {
  .menu-phone {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: block;
  }
}
.l_header {
  max-width: 65vw;
  left: calc((100% - 65vw) * 0.5);
  border-bottom-left-radius: 8px;
  border-bottom-right-radius: 8px;
}
@media screen and (max-width: 2048px) {
  .l_header {
    max-width: 1112px;
    left: calc((100% - 1112px) * 0.5);
  }
}
@media screen and (max-width: 1112px) {
  .l_header {
    left: 0;
    border-radius: 0;
    -webkit-border-radius: 0;
    max-width: 100%;
  }
}
@media screen and (max-width: 500px) {
  .l_header .container {
    margin-left: 0;
    margin-right: 0;
  }
  .l_header #wrapper .nav-main .title {
    padding-left: 16px;
    padding-right: 16px;
  }
  .l_header #wrapper .nav-sub {
    width: 100%;
  }
  .l_header #wrapper .nav-sub .title {
    overflow-y: scroll;
    margin-top: 2px;
    padding: 8px 16px;
  }
  .l_header #wrapper .switcher {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: -ms-flexbox /* TWEENER - IE 10 */;
    display: -webkit-flex /* NEW - Chrome */;
    display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
    display: flex;
    margin-right: 8px;
  }
  .l_header .menu {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: none;
  }
}
@media screen and (max-width: 500px) {
  .list-v li {
    max-width: 270px;
  }
}
#u-search {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  padding: 60px 20px;
  z-index: 1001;
}
@media screen and (max-width: 680px) {
  #u-search {
    padding: 0px;
  }
}

  </style>
  <link rel="stylesheet" href="/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css"></noscript>
  
<script>
if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode))
    document.write(
	'<style>'+
		'html{'+
			'overflow-x: hidden !important;'+
			'overflow-y: hidden !important;'+
		'}'+
		'.kill-ie{'+
			'text-align:center;'+
			'height: 100%;'+
			'margin-top: 15%;'+
			'margin-bottom: 5500%;'+
		'}'+
    '.kill-t{'+
      'font-size: 2rem;'+
    '}'+
    '.kill-c{'+
      'font-size: 1.2rem;'+
    '}'+
		'#l_header,#l_body{'+
			'display: none;'+
		'}'+
	'</style>'+
    '<div class="kill-ie">'+
        `<span class="kill-t"><b>Sorry, your browser cannot access this site</b></span><br/>`+
        `<span class="kill-c">Microsoft has terminated support for Internet Explorer (IE) 10 and earlier versions in 2016. <br/>There are great security risks to continue using it. Please use contemporary mainstream browsers to access.</span><br/>`+
        `<a target="_blank" rel="noopener" href="https://blogs.windows.com/windowsexperience/2021/05/19/the-future-of-internet-explorer-on-windows-10-is-in-microsoft-edge/"><strong>Learn more ></strong></a>`+
    '</div>');
</script>


<noscript>
	<style>
		html{
			overflow-x: hidden !important;
			overflow-y: hidden !important;
		}
		.kill-noscript{
			text-align:center;
			height: 100%;
			margin-top: 15%;
			margin-bottom: 5500%;
		}
    .kill-t{
      font-size: 2rem;
    }
    .kill-c{
      font-size: 1.2rem;
    }
		#l_header,#l_body{
			display: none;
		}
	</style>
    <div class="kill-noscript">
        <span class="kill-t"><b>Sorry, your browser cannot access this site</b></span><br/>
        <span class="kill-c">This page requires browser support (enable) JavaScript</span><br/>
        <a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=启用JavaScript"><strong>Learn more ></strong></a>
    </div>
</noscript>


  <script>
  /************这个文件存放不需要重载的全局变量和全局函数*********/
  window.volantis = {}; // volantis 全局变量
  volantis.debug = "env"; // 调试模式
  volantis.dom = {}; // 页面Dom see: /source/js/app.js etc.

  volantis.GLOBAL_CONFIG ={
    debug: "env",
    cdn: {"js":{"app":"/js/app.js","parallax":"/js/plugins/parallax.js","rightMenu":"/js/plugins/rightMenu.js","rightMenus":"/js/plugins/rightMenus.js","sites":"/js/plugins/tags/sites.js","friends":"/js/plugins/tags/friends.js","contributors":"/js/plugins/tags/contributors.js","search":"/js/search/hexo.js"},"css":{"style":"/css/style.css"}},
    default: {"avatar":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/avatar/round/3442075.svg","link":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/link/8f277b4ee0ecd.svg","cover":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/cover/76b86c0226ffd.svg","image":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/image/2659360.svg"},
    lastupdate: new Date(1697890111094),
    sidebar: {
      for_page: ["blogger","category","tagcloud","text"],
      for_post: ["toc"],
      webinfo: {
        lastupd: {
          enable: true,
          friendlyShow: true
        },
        runtime: {
          data: "2020/01/01",
          unit: "天"
        }
      }
    },
    plugins: {
      message: {"enable":true,"css":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/izitoast/dist/css/iziToast.min.css","js":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/izitoast/dist/js/iziToast.min.js","icon":{"default":"fa-solid fa-info-circle light-blue","quection":"fa-solid fa-question-circle light-blue"},"time":{"default":5000,"quection":20000},"position":"topRight","transitionIn":"bounceInLeft","transitionOut":"fadeOutRight","titleColor":"var(--color-text)","messageColor":"var(--color-text)","backgroundColor":"var(--color-card)","zindex":2147483647,"copyright":{"enable":true,"title":"知识共享许可协议","message":"请遵守 CC BY-NC-SA 4.0 协议。","icon":"far fa-copyright light-blue"},"aplayer":{"enable":true,"play":"fa-solid fa-play","pause":"fa-solid fa-pause"},"rightmenu":{"enable":true,"notice":true}},
      fancybox: {"css":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fancyapps/ui/dist/fancybox.css","js":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fancyapps/ui/dist/fancybox.umd.js"},
      
      
      
    }
  }

  /******************** volantis.EventListener ********************************/
  // 事件监听器 see: /source/js/app.js
  volantis.EventListener = {}
  // 这里存放pjax切换页面时将被移除的事件监听器
  volantis.EventListener.list = []
  //构造方法
  function volantisEventListener(type, f, ele) {
    this.type = type
    this.f = f
    this.ele = ele
  }
  // 移除事件监听器
  volantis.EventListener.remove = () => {
    volantis.EventListener.list.forEach(function (i) {
      i.ele.removeEventListener(i.type, i.f, false)
    })
    volantis.EventListener.list = []
  }
  /******************** volantis.dom.$ ********************************/
  // 注：这里没有选择器，也没有forEach一次只处理一个dom，这里重新封装主题常用的dom方法，返回的是dom对象，对象包含了以下方法，同时保留dom的原生API
  function volantisDom(ele) {
    if (!ele) ele = document.createElement("div")
    this.ele = ele;
    // ==============================================================
    this.ele.find = (c) => {
      let q = this.ele.querySelector(c)
      if (q)
        return new volantisDom(q)
    }
    // ==============================================================
    this.ele.hasClass = (c) => {
      return this.ele.className.match(new RegExp('(\\s|^)' + c + '(\\s|$)'));
    }
    this.ele.addClass = (c) => {
      this.ele.classList.add(c);
      return this.ele
    }
    this.ele.removeClass = (c) => {
      this.ele.classList.remove(c);
      return this.ele
    }
    this.ele.toggleClass = (c) => {
      if (this.ele.hasClass(c)) {
        this.ele.removeClass(c)
      } else {
        this.ele.addClass(c)
      }
      return this.ele
    }
    // ==============================================================
    // 参数 r 为 true 表示pjax切换页面时事件监听器将被移除，false不移除
    this.ele.on = (c, f, r = 1) => {
      this.ele.addEventListener(c, f, false)
      if (r) {
        volantis.EventListener.list.push(new volantisEventListener(c, f, this.ele))
      }
      return this.ele
    }
    this.ele.click = (f, r) => {
      this.ele.on("click", f, r)
      return this.ele
    }
    this.ele.scroll = (f, r) => {
      this.ele.on("scroll", f, r)
      return this.ele
    }
    // ==============================================================
    this.ele.html = (c) => {
      // if(c=== undefined){
      //   return this.ele.innerHTML
      // }else{
      this.ele.innerHTML = c
      return this.ele
      // }
    }
    // ==============================================================
    this.ele.hide = (c) => {
      this.ele.style.display = "none"
      return this.ele
    }
    this.ele.show = (c) => {
      this.ele.style.display = "block"
      return this.ele
    }
    // ==============================================================
    return this.ele
  }
  volantis.dom.$ = (ele) => {
    return !!ele ? new volantisDom(ele) : null;
  }
  /******************** RunItem ********************************/
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = ()=>{
          volantis.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) =>{
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index,1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }
  /******************** Pjax ********************************/
  // /layout/_plugins/pjax/index.ejs
  // volantis.pjax.send(callBack[,"callBackName"]) 传入pjax:send回调函数
  // volantis.pjax.push(callBack[,"callBackName"]) 传入pjax:complete回调函数
  // volantis.pjax.error(callBack[,"callBackName"]) 传入pjax:error回调函数
  volantis.pjax = {};
  volantis.pjax.method = {
    complete: new RunItem(),
    error: new RunItem(),
    send: new RunItem(),
  };
  volantis.pjax = Object.assign(volantis.pjax, {
    push: volantis.pjax.method.complete.push,
    error: volantis.pjax.method.error.push,
    send: volantis.pjax.method.send.push,
  });
  /******************** RightMenu ********************************/
  // volantis.rightmenu.handle(callBack[,"callBackName"]) 外部菜单项控制
  // 可在 volantis.mouseEvent 处获取右键事件
  volantis.rightmenu = {};
  volantis.rightmenu.method = {
    handle: new RunItem(),
  }
  volantis.rightmenu = Object.assign(volantis.rightmenu, {
    handle: volantis.rightmenu.method.handle.push,
  });
  /********************  Dark Mode  ********************************/
  // /layout/_partial/scripts/darkmode.ejs
  // volantis.dark.mode 当前模式 dark or light
  // volantis.dark.toggle() 暗黑模式触发器
  // volantis.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  volantis.dark = {};
  volantis.dark.method = {
    toggle: new RunItem(),
  };
  volantis.dark = Object.assign(volantis.dark, {
    push: volantis.dark.method.toggle.push,
  });
  /********************  Message  ********************************/
  // VolantisApp.message
  /********************  isMobile  ********************************/
  // /source/js/app.js
  // volantis.isMobile
  // volantis.isMobileOld
  /********************脚本动态加载函数********************************/
  // volantis.js(src, cb)  cb 可以传入onload回调函数 或者 JSON对象 例如: volantis.js("src", ()=>{}) 或 volantis.js("src", {defer:true,onload:()=>{}})
  // volantis.css(src)

  // 返回Promise对象，如下方法同步加载资源，这利于处理文件资源之间的依赖关系，例如：APlayer 需要在 MetingJS 之前加载
  // (async () => {
  //     await volantis.js("...theme.plugins.aplayer.js.aplayer...")
  //     await volantis.js("...theme.plugins.aplayer.js.meting...")
  // })();

  // 已经加入了setTimeout
  volantis.js = (src, cb) => {
    return new Promise(resolve => {
      setTimeout(function () {
        var HEAD = document.getElementsByTagName("head")[0] || document.documentElement;
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        if (cb) {
          if (JSON.stringify(cb)) {
            for (let p in cb) {
              if (p == "onload") {
                script[p] = () => {
                  cb[p]()
                  resolve()
                }
              } else {
                script[p] = cb[p]
                script.onload = resolve
              }
            }
          } else {
            script.onload = () => {
              cb()
              resolve()
            };
          }
        } else {
          script.onload = resolve
        }
        script.setAttribute("src", src);
        HEAD.appendChild(script);
      });
    });
  }
  volantis.css = (src) => {
    return new Promise(resolve => {
      setTimeout(function () {
        var link = document.createElement('link');
        link.rel = "stylesheet";
        link.href = src;
        link.onload = resolve;
        document.getElementsByTagName("head")[0].appendChild(link);
      });
    });
  }
  /********************按需加载的插件********************************/
  // volantis.import.jQuery().then(()=>{})
  volantis.import = {
    jQuery: () => {
      if (typeof jQuery == "undefined") {
        return volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/jquery/dist/jquery.min.js")
      } else {
        return new Promise(resolve => {
          resolve()
        });
      }
    }
  }
  /********************** requestAnimationFrame ********************************/
  // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
  // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
  volantis.requestAnimationFrame = (fn)=>{
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
    }
    window.requestAnimationFrame(fn)
  }
  /************************ layoutHelper *****************************************/
  volantis.layoutHelper = (helper, html, opt)=>{
    opt = Object.assign({clean:false, pjax:true}, opt)
    function myhelper(helper, html, clean) {
      volantis.tempDiv = document.createElement("div");
      volantis.tempDiv.innerHTML = html;
      let layoutHelper = document.querySelector("#layoutHelper-"+helper)
      if (layoutHelper) {
        if (clean) {
          layoutHelper.innerHTML = ""
        }
        layoutHelper.append(volantis.tempDiv);
      }
    }
    myhelper(helper, html, opt.clean)
    if (opt.pjax) {
      volantis.pjax.push(()=>{
        myhelper(helper, html, opt.clean)
      },"layoutHelper-"+helper)
    }
  }
  /****************************** 滚动事件处理 ****************************************/
  volantis.scroll = {
    engine: new RunItem(),
    unengine: new RunItem(),
  };
  volantis.scroll = Object.assign(volantis.scroll, {
    push: volantis.scroll.engine.push,
  });
  // 滚动条距离顶部的距离
  volantis.scroll.getScrollTop = () =>{
    let scrollPos;
    if (window.pageYOffset) {
      scrollPos = window.pageYOffset;
    } else if (document.compatMode && document.compatMode != 'BackCompat') {
      scrollPos = document.documentElement.scrollTop;
    } else if (document.body) {
      scrollPos = document.body.scrollTop;
    }
    return scrollPos;
  }
  // 使用 requestAnimationFrame 处理滚动事件
  // `volantis.scroll.del` 中存储了一个数值, 该数值检测一定时间间隔内滚动条滚动的位移, 数值的检测频率是浏览器的刷新频率. 数值为正数时, 表示向下滚动. 数值为负数时, 表示向上滚动.
  volantis.scroll.handleScrollEvents = () => {
    volantis.scroll.lastScrollTop = volantis.scroll.getScrollTop()
    function loop() {
      const scrollTop = volantis.scroll.getScrollTop();
      if (volantis.scroll.lastScrollTop !== scrollTop) {
        volantis.scroll.del = scrollTop - volantis.scroll.lastScrollTop;
        volantis.scroll.lastScrollTop = scrollTop;
        // if (volantis.scroll.del > 0) {
        //   console.log("向下滚动");
        // } else {
        //   console.log("向上滚动");
        // }
        // 注销过期的unengine未滚动事件
        volantis.scroll.unengine.list=[]
        volantis.scroll.engine.start();
      }else{
        volantis.scroll.unengine.start();
      }
      volantis.requestAnimationFrame(loop)
    }
    volantis.requestAnimationFrame(loop)
  }
  volantis.scroll.handleScrollEvents()
  volantis.scroll.ele = null;
  // 触发页面滚动至目标元素位置
  volantis.scroll.to = (ele, option = {}) => {
    if (!ele) return;
    volantis.scroll.ele = ele;
    // 默认配置
    opt = {
      top: ele.getBoundingClientRect().top + document.documentElement.scrollTop,
      behavior: "smooth"
    }
    // 定义配置
    if ("top" in option) {
      opt.top = option.top
    }
    if ("behavior" in option) {
      opt.behavior = option.behavior
    }
    if ("addTop" in option) {
      opt.top += option.addTop
    }
    if (!("observerDic" in option)) {
      option.observerDic = 100
    }
    // 滚动
    window.scrollTo(opt);
    // 监视器
    // 监视并矫正元素滚动到指定位置
    // 用于处理 lazyload 引起的 cls 导致的定位失败问题
    // option.observer = false
    if (option.observer) {
      setTimeout(() => {
        if (volantis.scroll.ele != ele) {
          return
        }
        volantis.scroll.unengine.push(() => {
          let me = ele.getBoundingClientRect().top
          if(!(me >= -option.observerDic && me <= option.observerDic)){
            volantis.scroll.to(ele, option)
          }
          volantis.scroll.unengine.remove("unengineObserver")
        },"unengineObserver")
      },1000)
    }
  }
  /********************** Content Visibility ********************************/
  // 见 source/css/first.styl 如果遇到任何问题 删除 .post-story 即可
  // 一个元素被声明 content-visibility 属性后 如果元素不在 viewport 中 浏览器不会计算其后代元素样式和属性 从而节省 Style & Layout 耗时
  // content-visibility 的副作用: 锚点失效 等等(实验初期 暂不明确), 使用此方法清除样式
  volantis.cleanContentVisibility = ()=>{
    if (document.querySelector(".post-story")) {
      console.log("cleanContentVisibility");
      document.querySelectorAll(".post-story").forEach(e=>{
        e.classList.remove("post-story")
      })
    }
  }
  /******************************************************************************/
  /******************************************************************************/
  /******************************************************************************/
  //图像加载出错时的处理
  function errorImgAvatar(img) {
    img.src = "https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/avatar/round/3442075.svg";
    img.onerror = null;
  }
  function errorImgCover(img) {
    img.src = "https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/cover/76b86c0226ffd.svg";
    img.onerror = null;
  }
  /******************************************************************************/
</script>

  <!-- import head_end begin -->
  <!-- import head_end end -->
  <!-- Custom Files headEnd begin-->
  
  <!-- Custom Files headEnd end-->
</head>
  <body itemscope itemtype="http://schema.org/WebPage">
    <!-- import body_begin begin-->
    <!-- import body_begin end-->
    <!-- Custom Files bodyBegin begin-->
    
    <!-- Custom Files bodyBegin end-->
    <header itemscope itemtype="http://schema.org/WPHeader" id="l_header" class="l_header auto shadow floatable blur show" style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fa-solid fa-comments fa-fw" target="_self"  href="/" onclick="return false;" title="comment"></a></li>
        
          <li><a id="s-toc" class="s-toc fa-solid fa-list fa-fw" target="_self"  href="/" onclick="return false;" title="toc"></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/" title="博客"
                  
                  
                  
                    active-action="action-home"
                  >
                  <i class='fa-solid fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/categories/" title="分类"
                  
                  
                  
                    active-action="action-categories"
                  >
                  <i class='fa-solid fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/tags/" title="标签"
                  
                  
                  
                    active-action="action-tags"
                  >
                  <i class='fa-solid fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/archives/" title="归档"
                  
                  
                  
                    active-action="action-archives"
                  >
                  <i class='fa-solid fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/about/" title="关于"
                  
                  
                  
                    active-action="action-about"
                  >
                  <i class='fa-solid fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>
      
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fa-solid fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>
      

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fa-solid fa-search fa-fw" target="_self" href="/" onclick="return false;" title="search"></a></li>
				
				<li>
          <a class="s-menu fa-solid fa-bars fa-fw" target="_self" href="/" onclick="return false;" title="menu"></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/" title="博客"
                  
                  
                  
                    active-action="action-home"
                  >
                  <i class='fa-solid fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/categories/" title="分类"
                  
                  
                  
                    active-action="action-categories"
                  >
                  <i class='fa-solid fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/tags/" title="标签"
                  
                  
                  
                    active-action="action-tags"
                  >
                  <i class='fa-solid fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/archives/" title="归档"
                  
                  
                  
                    active-action="action-archives"
                  >
                  <i class='fa-solid fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/about/" title="关于"
                  
                  
                  
                    active-action="action-about"
                  >
                  <i class='fa-solid fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>

      <!-- Custom Files header begin -->
      
      <!-- Custom Files header end -->
		</div>
	</div>
  </div>
</header>

    <div id="l_body">
      <div id="l_cover">
  
    
      <!-- see: /layout/_partial/scripts/_ctrl/coverCtrl.ejs -->
      <div id="none" class='cover-wrapper post search' style="display: none;">
        
  <div class='cover-bg lazyload placeholder' data-bg="https://pic2.imgdb.cn/item/6447e58d0d2dde57776e7fa8.jpg"></div>

<div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">一只小于</p>
    
    
      <p class="subtitle">Yu-Zhan-Hai</p>
    
  </div>
  <div class='bottom'>
    
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <input type="text" class="input u-search-input" placeholder="搜索一下" />
          <i class="icon fa-solid fa-search fa-fw"></i>
        </form>
      </div>
    
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/"
              
              
              active-action="action-home">
              <p>主页</p>
            </a>
          
            <a href="/tags/"
              
              
              active-action="action-tags">
              <p>标签</p>
            </a>
          
            <a href="/categories/"
              
              
              active-action="action-categories">
              <p>分类</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

        <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
      </div>
    
  
</div>

      <div id="safearea">
        <div class="body-wrapper">
          
<div id="l_main" class=''>
  <article itemscope itemtype="http://schema.org/Article" class="article post white-box reveal md shadow floatable blur article-type-post" id="post" itemscope itemprop="blogPost">
  <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/04/汇编语言学习笔记/">
  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Hexo">
  </span>
  <span hidden itemprop="post" itemscope itemtype="http://schema.org/Post">
    <meta itemprop="name" content="Hexo">
    <meta itemprop="description" content="wode">
  </span>
  


  
    <span hidden>
      <meta itemprop="image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
    </span>
  
  <div class="article-meta" id="top">
    
    
    
      <span hidden itemprop="name headline">
        
      </span>
    
  </div>


  <div id="layoutHelper-page-plugins"></div>
  <div id="post-body" itemprop="articleBody">
    <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h1 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章 基础知识"></a>第一章 基础知识</h1><h1 id="第二章-寄存器（CPU工作原理）"><a href="#第二章-寄存器（CPU工作原理）" class="headerlink" title="第二章 寄存器（CPU工作原理）"></a>第二章 寄存器（CPU工作原理）</h1><h1 id="第三章-寄存器（内存访问）"><a href="#第三章-寄存器（内存访问）" class="headerlink" title="第三章 寄存器（内存访问）"></a>第三章 寄存器（内存访问）</h1><h1 id="第四章-第一个程序"><a href="#第四章-第一个程序" class="headerlink" title="第四章 第一个程序"></a>第四章 第一个程序</h1><h1 id="第五章-BX-和loop指令"><a href="#第五章-BX-和loop指令" class="headerlink" title="第五章 [BX]和loop指令"></a>第五章 [BX]和loop指令</h1><h1 id="第六章-包含多个段的程序"><a href="#第六章-包含多个段的程序" class="headerlink" title="第六章 包含多个段的程序"></a>第六章 包含多个段的程序</h1><h1 id="第七章-更灵活定位内存地址"><a href="#第七章-更灵活定位内存地址" class="headerlink" title="第七章 更灵活定位内存地址"></a>第七章 更灵活定位内存地址</h1><h1 id="第八章-数据处理的两个基本问题"><a href="#第八章-数据处理的两个基本问题" class="headerlink" title="第八章 数据处理的两个基本问题"></a>第八章 数据处理的两个基本问题</h1><h1 id="第九章-转移指令的原理"><a href="#第九章-转移指令的原理" class="headerlink" title="第九章 转移指令的原理"></a>第九章 转移指令的原理</h1><h1 id="第十章-call和ret指令"><a href="#第十章-call和ret指令" class="headerlink" title="第十章 call和ret指令"></a>第十章 call和ret指令</h1><h1 id="第十一章-标志寄存器"><a href="#第十一章-标志寄存器" class="headerlink" title="第十一章 标志寄存器"></a>第十一章 标志寄存器</h1><h1 id="第十二章-内中断"><a href="#第十二章-内中断" class="headerlink" title="第十二章 内中断"></a>第十二章 内中断</h1><h1 id="第十三章-int指令"><a href="#第十三章-int指令" class="headerlink" title="第十三章 int指令"></a>第十三章 int指令</h1><h1 id="第十四章-端口"><a href="#第十四章-端口" class="headerlink" title="第十四章 端口"></a>第十四章 端口</h1><h1 id="第十五章-外中断"><a href="#第十五章-外中断" class="headerlink" title="第十五章 外中断"></a>第十五章 外中断</h1><h1 id="第十六章-直接定址表"><a href="#第十六章-直接定址表" class="headerlink" title="第十六章 直接定址表"></a>第十六章 直接定址表</h1><h1 id="第十七章-使用BIOS进入键盘输入和磁盘读写"><a href="#第十七章-使用BIOS进入键盘输入和磁盘读写" class="headerlink" title="第十七章 使用BIOS进入键盘输入和磁盘读写"></a>第十七章 使用BIOS进入键盘输入和磁盘读写</h1><h1 id="第〇章-课程资料"><a href="#第〇章-课程资料" class="headerlink" title="第〇章 课程资料"></a>第〇章 课程资料</h1><pre><code>1.课件+源代码
2.《汇编语言(第3版) 》王爽著 电子书
3.课后习题答案
百度云：
</code></pre>
<h1 id="第一章-基础知识-1"><a href="#第一章-基础知识-1" class="headerlink" title="第一章 基础知识"></a>第一章 基础知识</h1><pre><code>【学习汇编主要是：学习汇编的编程思想，掌握机器运行的思维】
汇编语言是直接在硬件上工作的编程语言，首先要了解硬件系统的结构，才能有效的应用汇编语言对其编程。
1.汇编课程的研究重点
    如何利用硬件系统的编程结构和指令集有效灵活的控制系统进行工作
2.汇编语言的主体是汇编指令
3.汇编指令和机器指令的差别在于指令的表示方法上
    汇编指令是机器指令便于记忆的书写格式
4.汇编语言时机器指令的助记符
5.汇编语言的组成
    1.汇编指令（机器码的助记符）
    2.伪指令（由编译器执行）
    3.其他符号（由编译器识别，如：+ - * /）
    汇编语言的核心是汇编指令，他决定了汇编语言的特性
6.CPU对存储器的读写
    CPU要想进行数据的读写，必须和外部器件（即芯片）进行三类信息的交互
    1.地址信息：存储单元的地址
    2.控制信息：芯片的选择，读或写命令
    3.数据信息：读或写的数据
</code></pre>
<h1 id="第二章-寄存器（CPU工作原理）-1"><a href="#第二章-寄存器（CPU工作原理）-1" class="headerlink" title="第二章 寄存器（CPU工作原理）"></a>第二章 寄存器（CPU工作原理）</h1><pre><code>CPU=运算器+控制器+【寄存器】，器件之间通过总线相连
8086CPU有14个寄存器，名称分别为：
    AX，BX，CX，DX，SI，DI，SP，BP，IP，CS，SS，DS，ES，PSW	
2.1 通用寄存器
    1.8086CPU所有的寄存器都是16位的，可以存放2个字节
    2.AX、BX、CX、DX通常用来存放一般性数据
        被称为通用寄存器
    3.8086上一代CPU中的寄存器都是8位的，为了保证兼容性
        这四个寄存器都是可以分为2个独立的8位寄存器使用
        AX=AH+AL
        BX=BH+BL
        CX=CH+CL
        DX=DH+DL
    4.AX的低8位（0-7）构成AL寄存器
        高8位（8-15）构成了AH寄存器
        AH和AL寄存器是可以独立使用的8位寄存器
2.2 字在寄存器中的存储
    8086一个字16位
</code></pre>
<p><img src="/img_ass/2.1.png" class="lazyload" data-srcset="/img_ass/2.1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="avatar"></p>
<pre><code>2.3 几条汇编指令
    1.汇编指令不区分大小写 
    2.几条汇编指令
        mov ax,18	;AX=18
        mov ah,78	;AH=78
        add ax,8	;AX=AX+8
        mov ax,bx	;AX=BX
        add ax,bx	;AX+=BX
    3.用目前学过的汇编指令，最多使用四条指令，编程计算2的4次方
        mov ax,2	;ax=2
        add ax,ax	;ax=4
        add ax,ax	;ax=8
        add ax,ax	;ax=16
2.4 物理地址
    1.CPU访问内存单元时，要给出内存单元的地址。
    2.所有的内存单元够成的存储空间是一个一维的线性空间
    3.我们将这个唯一的地址称为物理地址
2.5 16位结构的CPU
    16位结构描述了一个淳朴具有以下几个方面特征：
        1.运算器一次最多可以处理16位的数据
        2.寄存器的最大宽度为16位
        3.寄存器和运算器之间的通路是16位的
2.6 8086CPU给出物理地址的方法
    1.8086有20位地址总线，可传送20位地址，实际上的寻址能力为1M
    2.8086内部为16位结构，它只能传送16位的地址，理论上表现出的寻址能力却只有64K
    3.问题：8086CPU如何用内部16位的数据转换成20位的地址？
        1.8086CPU采用一种在内部用两个16位地址合成的方法，来形成20位的物理地址
            即：段地址+偏移地址=物理地址
        2.地址加法器合成物理地址的方法：
            物理地址=段地址×16+偏移地址
        3.“地址段×16”即是数据左移4位（二进制位的左移4位，十六进制的左移1位）
            在地址加法器中，如何完成“段地址×16”？
            二进制形式的段地址左移4位
2.7 “段地址×16+偏移地址=物理地址”的本质含义
    1.即可以用两个16位的二进制数来表示一个20位的二进制数
    2.8086CPU中内部为16位结构，但地址线却是20位的，使用地址加法器可以把16位地址变成20位地址
        具体操作就是：段地址×16+偏移地址	    
2.8 段的概念
    1.内存并没有分段，段的划分来自于CPU，由于8086CPU用“段地址×16+偏移地址=物理地址”
        的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存
    2.以后，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，
        使用段地址×16定位段的起始地址（基础地址），用偏移地址定位段中的内存单元
    3.注意
        1.段地址必然是16的倍数，即一个段的起始地址必然是16的倍数
        2.偏移地址为16位，16位地址的寻址能力为64K，所以一个段的长度最大为64K
        3.CPU可以用不同的段地址和偏移地址形成同一个物理地址
2.9 段寄存器
    1.段寄存器就是提供段地址的
        8086CPU有4个段寄存器：
        1.CS（code segment）
        2.DS（data segment）
        3.SS（stack segment）
        4.ES（extra segment）
    2.当8086CPU要访问内存时，有这4个段寄存器提供内存单元的段地址
2.10 CS和IP
    1.CS和IP时候8086CPU中最关键的寄存器
        他们指示了CPU当前读取指令的地址。
    2.CS和IP的含义
        CS：代码段寄存器
        IP：指令指针寄存器【专用寄存器】
    3.8086CPU工作过程的简要描述
        1.从CS:IP指向内存单元，读取指令，读取的指令进入指令缓冲器
        2.IP=IP+所读取指令的长度，从而指向下一条指令
        3.执行指令，转到步骤1，重复这个过程
    4.开机时的CS和IP
        1.在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为
            CS=FFFFH，IP=0000H
        2.即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令执行
        3.FFFF0H单元中的指令是8086PC机开机后执行的第一条指令
    5.修改CS、IP的指令
        1.在CPU中，程序员能够【用指令读写】的部件只有【寄存器】，
            程序员可以通过改变寄存器中的内容实现对CPU的控制
        2.CPU从何处执行指令是由CS、IP中的内容决定的，程序员可以通过改变CS、IP中的内容
            控制CPU执行目标指令
        3.如何修改CS和IP？
            1.通过mov改变AX等，但是不能通过mov改变CS和IP
            2.【jmp 段地址:偏移地址】  可以用来同时修改CS和IP
                指令中的段地址修改CS
                偏移地址修改IP
            3.【jmp 某一合法的寄存器】   仅修改IP的内容
                比如：jmp ax 或者 jmp bx（类似于mov IP ax）
            4.jmp是只具有一个操作对象的指令
2.11 代码段
    1.可以将长度为N（N&lt;=64KB）的一组代码，存放在一组地址连续、其实地址为16的倍数的内存单元中
        这段内存是用来存放代码的，从而定义了一个代码段
    2.CPU中只认被CS:IP指向的内存单元中的内容为指令
【实验一】查看CPU和内存，用机器指令和汇编指令编程
    1.R命令：查看、改变CPU寄存器的内容
        r后面加寄存器的名称可以改变CPU寄存器的内容
    2.D命令：查看内存中的内容
    3.E命令：改写内存中的内容
    4.U命令：将内存汇总的机器指令翻译成汇编指令
    5.T命令：执行一条机器指令
    6.A命令：以汇编指令的格式在内存中写入一条机器指令
        1.debug中输入的默认是16位数
        2.空格数量任意
    7.按Q可以退出
</code></pre>
<h1 id="第三章-寄存器（内存访问）-1"><a href="#第三章-寄存器（内存访问）-1" class="headerlink" title="第三章 寄存器（内存访问）"></a>第三章 寄存器（内存访问）</h1><pre><code>3.1 内存中字的存储
</code></pre>
<p><img src="/img_ass/3.1.png" class="lazyload" data-srcset="/img_ass/3.1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="avatar"></p>
<pre><code>    1.任何两个地址连续的内存单元，N号单元和N+1号单元，可以将他们看成两个存储单元
        也可以看成一个地址为N的字单元中的高位字节单元和低位字节单元
    2.注意：在内存的表示中，从高到低，是从0号单元开始，然后逐渐变大，
        即在书写时，低位写在高的地方，高位写在低的地方，
        如上图所示：4E20H即是0号字节存储20，1号字节存储4E
3.2 DS和[address]
    1.8086中有一个DS寄存器，通常用来存放要访问的数据的段地址
    2.例如：我们要读取10000H单元的内容可以用如下程序段进行：
        mov bx,1000H
        mov ds,bx
        mov al,[0]
      上面的三条指令将10000H（1000:0）中的数据读到al中
        1.复习：已知mov指令可以完成的两种传送功能
            1.将数据直接送入寄存器
            2.将一个寄存器中的内容送入另一个寄存器中
        2.除此之外，mov指令还可以将一个内存单元中的内容送入一个寄存器
            mov指令格式：mov 寄存器名,内存单元地址
            [...]表示一个内存单元，“[...]”中的...表示内存单元的【偏移地址】
            执行指令时，8086CPU自动取DS中的数据为内存单元的【段地址】
        3.如何把1000H放入DS中？
            要通过通用寄存器把段地址传入到DS中
            8086CPU不支持将数据直接送入段寄存器的操作，DS是一个段寄存器
            即：mov ds,1000H  是非法的
            数据-&gt;通用寄存器-&gt;段寄存器
    3.写几条指令，将AL中的数据送入内存单元10000H？
        mov bx,1000H
        mov ds,bx
        mov [0],al      ;al中的字节型数据送入到1000H:0中
3.3 字的传送
    1.8086CPU是16位结构，有16根数据线，所以可以一次性传送16位的数据
        即：一次可以传送一个字
    2.比如
        mov bx,1000H
        mov ds,bx
        mov ax,[0]      ;1000H:0处的字型数据送入ax中
        mov [0],cx      ;cx中的16位数据送入到1000H:0中
3.4 mov、add、sub指令
    1.复习：已学mov指令的几个形式
        1.mov 寄存器,数据         ;立即寻址
        2.mov 寄存器,寄存器        ;寄存器寻址
        3.mov 寄存器,内存单元      ;直接寻址
        4.mov 内存单元,寄存器      ;寄存器寻址？
        5.mov 段寄存器,寄存器      ;寄存器寻址
        6.mov 寄存器,段寄存器      ;寄存器寻址
    2.add、sub同mov一样，都有两个操作对象
        1.add的用法
            1.add 寄存器,数据      ;立即寻址
            2.add 寄存器,寄存器    ;寄存器寻址
            3.add 寄存器,内存单元  ;直接寻址
            4.add 内存单元,寄存器  ;
        2.sub的用法
            【不带借位的减法】
            指令格式 sub op1,op2    ;意为：op1=op1-op2
            1.sub 寄存器,数据      ;立即寻址
            2.sub 寄存器,寄存器    ;寄存器寻址
            3.sub 寄存器,内存单元  ;直接寻址
            4.sub 内存单元,寄存器  ;
3.5 数据段
    如何访问数据段中的数据？
        将一段内存当作数据段，是我们在编程时的一种安排
        具体操作：用DS存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元
3.6 栈
    1.8086CPU提供相关的指令来以栈的方式访问内存空间
        这意味着，我们在基于8086CPU编程的时候，可以将一段内存当作栈来使用
    2.8086CPU提供入栈和出栈指令：（最基本的）
        push（入栈）
        pop（出栈）
        1.push ax：将寄存器ax中的数据送入栈中
        2.pop ax：从栈顶取出数据送入ax
        3.8086CPU的入栈和出栈操作都是以【字（16位）】为单位进行的
        4.pop和push可以在寄存器和内存之间传送数据
    3.CPU如何知道一段内存空间被当做栈使用？
        1.8086CPU中，有两个寄存器
            1.段寄存器SS：存放栈顶的段地址
            2.寄存器SP：存放栈顶的偏移地址【专用寄存器】
        2.任意时刻SS:SP指向栈顶元素，当栈为空的时候，也就不存在栈顶元素
            ss:sp也就指向栈最高地址单元的下一个单元
    4.执行push和pop的时候，如何知道哪个单元是栈顶单元？
        1.执行push ax时
            1.sp=sp-2
            2.将ax中的内容送入到ss:sp指向的内存单元
                ss:sp此时指向新栈顶
        2.执行pop ax时
            1.将ss:sp指向的内存单元的内容送入到ax中
                注意：这里取出的内容在内存中还是存在的，并没有被重置
                    下一轮push会覆盖
            2.sp=sp+2
    5.如果栈是空的，sp指向哪里？
        sp指向最高地址单元的下一个单元
3.7 栈顶超界的问题
    ss、sp只记录了栈顶的地址，依靠ss、sp可以保证在入栈和出栈时找到栈顶
    可以，如何能够保证在入栈、出栈时，栈顶不会超出栈空间？
    1.8086CPU不保证栈的操作不会越界
    2.当栈空的时候，再执行pop出栈 或者 当栈满的时候再使用push入栈
        都会发生栈顶超界问题，会操作到栈以外的数据，
        这些数据可能是其他用途的数据或者代码
        栈顶超界是危险的！！！
    3.8086CPU没有记录栈顶上下限的寄存器
3.8 栈段
    1.将一段内存当做栈段，仅仅是我们在编程时的一种安排，
    2.ss:sp指向我们定义的栈段的栈顶；
    3.当栈空时，sp指向最高地址的下一个单元
    4.思考：一个栈段最大可以设为多少？
        64KB
    5.设栈顶的变化范围是0-FFFFH，从栈空时sp=0（最高地址单元FFFFH的下一个单元0000H）
        一直压栈，直到栈满，sp=0；
        如果再次压栈，栈顶将环绕，覆盖原来栈中的内容
    6.一段内存，既可以是代码的存储空间，又可以是数据的存储空间，还可以是栈空间
        也可以是什么都属实。
        关键在于CPU中寄存器的设置，即：cs、ip、ss、sp、ds的设置
        **可以通过mov直接给sp赋值【立即数寻址】，但是不能通过mov给cs、ip、ss、ds赋值
            给cs和ip赋值需要使用jum指令
            给ss和ds赋值需要使用mov ss或ds,寄存器   ;【寄存器寻址】
【实验二】
</code></pre>
<h1 id="第四章-第一个汇编程序"><a href="#第四章-第一个汇编程序" class="headerlink" title="第四章 第一个汇编程序"></a>第四章 第一个汇编程序</h1><pre><code>4.1 一个源程序从写出到执行的过程
    1.一个汇编语言程序从写出到最终执行的简要过程
        编写-&gt;编译连接-&gt;执行
    2.对源程序进行编译连接
        1.使用汇编语言编译程序（MASM.EXE）对源程序文件中的源程序进行编译，产生目标文件【.obj文件】
        2.再用连接程序（LINK.EXE）对目标文件进行连接，生成可在操作系统中直接运行的可执行文件【.EXE文件】。
    3.可执行文件包含两部分内容
        1.程序（从源程序的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）
        2.相关的描述信息（比如：程序有多大、要占多少内存空间等）
    4.执行可执行文件中的程序
        1.在操作系统（如：MSDOS）中，执行可执行文件中的程序
        2.操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存
            并进行相关的初始化（比如：设置CS:IP指向第一条要执行的指令），然后由CPU执行程序
4.2 源程序的主要结构
    源程序由 汇编指令+伪指令+宏指令 组成
        伪指令：编译器处理
        汇编指令：编译为机器码	
    1.伪指令
        1.没有对应的机器码的指令，不能由CPU直接执行
        2.伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作
    2.segment和ends【定义一个段】
        1.segment和ends是一对成对使用的伪指令
        2.编写汇编程序【必须】使用到的指令
        3.segment和ends的功能是定义一个段
            segment：说明一个段开始
            ends：说明一个段结束
        4.一个段必须有一个名称来标识，使用格式为
            段名 segment
            段名 ends
        5.一个汇编程序由多个段组成
            这些段用来存放【代码、数据、或当作栈空间】来使用
            一个有意义的汇编程序至少要有一个段，这个段用来存放代码。
    3.end【真正的没了】
        1.end是一个汇编程序的结束标记
        2.编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对源程序的编译
        3.如果程序写完了，要在结尾处加上伪指令end
            否则，编译器无法知道程序在何处结束
        4.【切记】不要把end和ends搞混了
            end：汇编程序的结束标记
            ends：与segment成对出现
    4.assume【寄存器和段的关联假设】
        1.它假设某一段寄存器和程序中的某一个用segment...ends定义的段相关联
        2.通过assume说明这种关联，在需要的情况下，
            编译程序可以将段寄存器和某一具体的段相联系
    5.程序和源程序
        1.我们将源程序文件中的所有内容称为【源程序】
        2.将源程序中最终由计算机执行处理的指令或数据称为【程序】
        3.程序最先以汇编指令的形式，存储在源程序中
            然后经过编译、连接后转变为机器码，存储在可执行文件中
    6.标号，标号与段名称有所区别
        1.一个标号指代了一个地址，即是段名称。
        2.段名称 放在segment的前面，作为一个段的名称
            这个段的名称最终将被汇编、连接程序处理为一个段的段地址
    7.DOS中的程序运行
        1.DOS是一个单任务操作系统
        2.一个程序结束后，将CPU的控制权交还给是他得以运行的程序
            我们称这个过程为：程序返回
    8.程序返回
        mov ax，4c00H
        int 21H      ;【中断机制】是DOS最伟大的机制,Windows系统上是【消息机制】
        这两条指令所实现的功能就是程序返回
    9.几个和结束相关的内容
        1.段结束：伪指令
            通知编译器一个段的结束【ends】
        2.程序结束：伪指令
            通知编译器程序的结束【end】
        3.程序返回：汇编指令
            mov ax,4c00H
            int 21H
    10.语法错误和逻辑错误
        1.语法错误
            1.程序在编译时被编译器发现的错误
            2.容易发现
        2.逻辑错误
            1.在编写时不会表现出来的错误、在运行时会发生的错误
            2.不容易发现
4.3 以简化的方式进行汇编和连接
    汇编使用的程序：masm.exe
    连接使用的程序：link.exe
    简化方式进行汇编和连接的程序：ml.exe
4.4 汇编和连接的作用
    连接的作用
    1.当源程序很大时，可以将他们分成多个源程序文件夹编译
        每个源程序编译成为目标文件后，再用连接程序将它们连接在一起，
        生成一个可执行文件
    2.程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起
        生成一个可执行文件
    3.一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接
        用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。
      所以在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用
        连接程序对目标文件进行处理，生成可执行文件
4.5 可执行文件中的程序装入内存并运行的原理
    1.在DOS中，可执行文件中的程序P1若要运行，必须有一个正在运行的程序P2
        将P1从可执行文件中加载入内存，将CPU的控制权交给P1，P1才能得以运行
    2.当P1运行完毕后，应该将CPU的控制权交还给使他得以运行的程序
    3.操作系统的外壳
        1.操作系统是由多个功能模块组成的庞大、复杂的软件系统
            任何通用的操作系统，都需要提供一个称为shell（外壳）的程序，
            用户（操作人员）使用这个程序来操作计算机系统工作
        2.DOS中有一个程序command.com，这个程序在DOS中称为命令解释器
            也就是DOS系统的shell
    4.执行可执行文件1.exe时，
      （1）什么程序将CPU的控制权交给了1.exe？
      （2）将程序1.exe加载入内存后，如何使程序得以运行？
      （3）1.exe程序运行结束后，返回到了哪里？
        1.在DOS中直接执行1.exe时，是正在运行的cmd.exe将1.exe中的程序加载入内存
        2.cmd.exe设置CPU的CS:IP指向程序的第一条指令（即，程序的入口）
            从而使程序得以运行
        3.程序运行结束后，返回cmd.exe中，CPU继续运行cmd.exe
【实验三】
</code></pre>
<h1 id="第五章-【bx】和loop指令"><a href="#第五章-【bx】和loop指令" class="headerlink" title="第五章 【bx】和loop指令"></a>第五章 【bx】和loop指令</h1><pre><code>5.1 [bx]
    1.和[0]类似，[0]表示内存单元，它的偏移地址是0；
    2.[bx]同样也表示一个内存单元，它的段地址在DS中
        它的偏移地址在bx中，至于是取字还是取字节，
        要看他放入的寄存器是8位还是16位
    3.补充：inc指令：相当于C语言中的++运算符
5.2 Loop指令
    这个指令和循环有关
    1.指令格式：loop 标号
        CPU执行loop指令的时候，要进行两步操作
        1.(cx)=(cx)-1;
        2.判断cx中的值，若不为零，则转至标号处执行程序
            若为零，则向下执行。
    2.通常，loop指令实现循环，cx中存放循环的次数
    3.标号
        在汇编语言中，标号代表了一个地址，标号标识了一个地址
    4.使用cx和loop指令相配合实现循环功能的三个要点
        1.在cx中存放循环次数
        2.loop指令中的标号所标识地址要在前面
        3.要循环执行的程序段，要写在标号和loop指令的中间
    5.用cx和loop指令相配合实现循环功能的程序框架
        mov cx,循环次数
      S:循环执行的程序段
        loop s
5.3 在Debug中跟踪供loop指令实现的循环程序
    **注意：在汇编程序中，数据不能以字母开头，如果要输入像FFFFH这样的数
        则要在前面添加一个0
    在debug程序中引入G命令和P命令
    1.G命令
        G命令如果后面不带参数，则一直执行程序，直到程序结束
        G命令后面如果带参数，则执行到ip为那个参数地址停止
    2.P命令
        T命令相当于单步进入（step into）
        P命令相当于单步通过（step over）
5.4 Debug和汇编编译器Masm对指令的不同处理
    1.在debug中，可以直接用指令 mov ax,[0] 将偏移地址为0号单元的内容赋值给ax
    2.但通过masm编译器，mov ax,[0] 会被编译成 mov ax,0
        1.要写成这样才能实现：mov ax,ds:[0]
        2.也可以写成这样：
            mov bx,0
            mov ax,[bx]  ;或者mov ax,ds:[bx]
5.5 loop和[bx]的联合应用
    1.计算ffff:0~ffff:b单元中的数据的和，结果存储在dx中
        1.注意两个问题
            1.12个8位数据加载一起，最后的结果可能会超出8位（越界），故要用16位寄存器存放结果
            2.将一个8位的数据加入到16位寄存器中，类型不匹配，8位的数据不能与16位相加
        2.【解决办法】
            把原来8位的数据，先通过通用寄存器ax，将它们转化成16位的
        3.代码如下
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:</span><br><span class="line">	;指定数据段</span><br><span class="line">	mov ax,0ffffh</span><br><span class="line">	mov ds,ax</span><br><span class="line">	</span><br><span class="line">	;初始化</span><br><span class="line">	mov ax,0</span><br><span class="line">	mov dx,0</span><br><span class="line">	mov bx,0</span><br><span class="line">	</span><br><span class="line">	;指定循环次数，12次</span><br><span class="line">	mov cx,0ch</span><br><span class="line">circ:</span><br><span class="line">	;把8位数据存入al中,即ax中存放的是[bx]转化之后的16位数据，前8位都是0</span><br><span class="line">	mov al,[bx]</span><br><span class="line">	;进行累加</span><br><span class="line">	add dx,ax</span><br><span class="line">	;bx自增，变化内存的偏移地址</span><br><span class="line">	inc bx</span><br><span class="line">	loop circ</span><br><span class="line">	</span><br><span class="line">	;程序返回</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21H</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start    </span><br></pre></td></tr></table></figure>
<pre><code>5.6 段前缀
    1.指令“mov ax,[bx]”中，内存单元的偏移地址由bx给出，而段地址默认在ds中
    2.我们可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器
        比如  mov ax,ds:[0]
              mov ax,ds:[bx]
        这里的ds就叫做【段前缀】
5.7 一段安全的空间
    1.8086模式中，随意向一段内存空间写入内容是很危险的
        因为这段空间中可能存放着【重要的系统数据或代码】
    2.在一般的PC机中，DOS方式下，DOS和其他合法的程序一般都不会使用【0:200~0:2FF】
        的256个字节的空间。所以，我们使用这段空间是安全的    
</code></pre>
<h1 id="第六章-包含多个段的程序-1"><a href="#第六章-包含多个段的程序-1" class="headerlink" title="第六章 包含多个段的程序"></a>第六章 包含多个段的程序</h1><pre><code>6.1在代码段中使用数据
    1.dw的含义【定义字型数据：define word，16字节】
        在数据段中使用dw定义数据，则数据在数据段中
        在代码段中使用dw定义数据，则数据在代码段中
        堆栈段也是一样
    2.在程序的第一条指令前加一个标号start，并且这个标号在伪指令end后面出现
        可以通知编译器程序在什么地方结束，并且也可以通知编译器程序的入口在哪里
6.2在代码段中使用栈
    **补充：如果题目要求【逆序】存放，就要想到栈（FILO）
    使用dw向系统申请一段空间，然后把这个空间当做栈
6.3将数据、代码、栈放入不同的段
    1.在前面的6.1和6.2中，我们在程序中用到了数据和栈，我们在编程的时候要注意
        何处是数据，何处是栈、何处是代码
    2.这样做显然有两个问题
        1.把他们放在一个段中是程序显得混乱
        2.前面程序中处理的数据很少，用到的栈空间也小，放在一个段里面没有问题
            但数据、栈、代码需要的空间超过64KB，就不能放在一个段中
            (8086中一个段的容量不能大于64KB)
    3.我们可以和定义代码段一样的方法来定义多个段
        然后在这些段里面定义需要的数据，或通过定义数据来取得栈空间
    4.将数据、代码、栈放入不同的段
        1.我们可以在源程序中为这三个段起具有含义的名称
            用来存放数据的段，我们将其命名为“data”
            用来存放代码的段，我们将其命名为“code”
            用来作栈空间的段，我们将其命名为“stack”
          但是CPU看得懂吗？【不能】
        2.我们在源程序中用伪指令
            “assume cs:code,ds:data,ss:stack”将cs、ds和ss分别和code、data、stack段相连
            这样做了之后，CPU是都就会将cs指向code，ds指向data，ss指向stack
              从而按照我们的意图来处理这些段呢？【不能】
              伪指令CPU看不懂，伪指令是给编译器看的
        3.若要CPU按照我们的安排行事，就要用机器指令控制它，源程序中的汇编指令
            才是CPU要执行的内容
            需在在code段中给DS，CS、SS设置相应的值才能让CPU识别出数据段、代码段、堆栈段
            其中汇编程序开始的地方（即代码段开始的地方）由end后面的标号所指向的地方给出
    5.assume指令不可省略，至于为什么，需要以后多多体会
【实验五】
    1.如果段中的数据占N个字节，则程序加载后，这段实际占有的空间为：N%16==0?N:16×(N/16+1);
        因为一个段最小占用16字节，即有16个字节只有这个段可以访问到
    2.在编辑源程序的时候，如果调换各个段的编写位置，最后CS、DS、SS的值会发生变化
    3.如果去掉start，编译器会从上到下执行，如果第一个段是代码段，则可以正常运行
        若第一个段不是代码段，则不会正常运行
    4.代码示例1
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">;数据段</span><br><span class="line">data segment</span><br><span class="line">    ;8个数据</span><br><span class="line">	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">;栈段</span><br><span class="line">stack segment</span><br><span class="line">	;8个数据</span><br><span class="line">    dw 0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">;代码段</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	;栈空间初始化</span><br><span class="line">	mov ax,stack</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov sp,16</span><br><span class="line">	</span><br><span class="line">	;数据段初始化</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	</span><br><span class="line">	push ds:[0];一个栈单元是一个字</span><br><span class="line">	push ds:[2]</span><br><span class="line">	;存放数据不会改变</span><br><span class="line">	pop ds:[2]</span><br><span class="line">	pop ds:[0]</span><br><span class="line">	</span><br><span class="line">	;程序返回</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end </span><br></pre></td></tr></table></figure>
<pre><code>    5.将a，b数据段中的内容分别相加，结果放入data数据段中
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">;数据段</span><br><span class="line">a segment</span><br><span class="line">	db 1,2,3,4,5,6,7,8</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">;数据段</span><br><span class="line">b segment</span><br><span class="line">	db 1,2,3,4,5,6,7,8</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">;数据段</span><br><span class="line">data segment</span><br><span class="line">	db 0,0,0,0,0,0,0,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">;代码段</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov ax,0</span><br><span class="line">	</span><br><span class="line">	mov dx,a</span><br><span class="line">	mov ss,dx</span><br><span class="line">	</span><br><span class="line">	mov dx,b</span><br><span class="line">	mov es,dx</span><br><span class="line">	</span><br><span class="line">	mov dx,data</span><br><span class="line">	mov ds,dx</span><br><span class="line"></span><br><span class="line">	mov cx,8</span><br><span class="line">circ:</span><br><span class="line">	add al,ss:[bx]</span><br><span class="line">	add al,es:[bx]</span><br><span class="line">	mov [bx],al</span><br><span class="line">	inc bx</span><br><span class="line">	mov al,0</span><br><span class="line">	loop circ</span><br><span class="line">	</span><br><span class="line">	;程序返回</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<pre><code>    6.将a数据段中的前8个字型数据逆序存储到b段中
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">a segment</span><br><span class="line">	dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffh</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b segment</span><br><span class="line">	dw 0,0,0,0,0,0,0,0</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,0</span><br><span class="line">	mov ax,a</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov sp,0</span><br><span class="line">	</span><br><span class="line">	mov ax,0</span><br><span class="line">	mov ax,b</span><br><span class="line">	mov ds,ax</span><br><span class="line">	</span><br><span class="line">	mov bx,0</span><br><span class="line">	</span><br><span class="line">	mov cx,8</span><br><span class="line">circ:</span><br><span class="line">	pop [bx]</span><br><span class="line">	add bx,2</span><br><span class="line">	loop circ</span><br><span class="line"></span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start </span><br></pre></td></tr></table></figure>
<h1 id="第七章-更灵活地定位内存地址"><a href="#第七章-更灵活地定位内存地址" class="headerlink" title="第七章 更灵活地定位内存地址"></a>第七章 更灵活地定位内存地址</h1><pre><code>本章主要讲解一些更灵活的定位内存地址的方法和相关的编程方法
7.1 and和or指令
    1.and指令：逻辑与指令，按位进行与运算
        1.如:mov al,01100011B
             and al,00111011B
          执行后：
             al=00100011B
        2.通过and指令可将操作对象的相应位设为0，其他位保持不变
            例如al的第6位设为0：and al,10111111B
            例如al的第7位设为0：and al,01111111B
            例如al的第0位设为0：and al,11111110B
    2.or指令，逻辑或运算，按位进行或运算
        1.如:mov al,01100011B
             or  al,00111011B
          执行后：
            al=01111011B
        2.通过该指令可将操作对象的相应位设为1，其他位不变
            or al,01000000B;将al的第6位设为1
            or al,10000000B;将al的第7位设为1
            or al,00000001B;将al的第0位设为1
7.2 关于ASCII码
    一种编码方案，在计算机系统中通常被采用，8位
</code></pre>
<p><img src="/img_ass/ASCII.png" class="lazyload" data-srcset="/img_ass/ASCII.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="avatar"></p>
<pre><code>7.3 以字符形式给出的数据
    1.在汇编程序中，可以使用&#39;×××&#39;的方式指明数据是以字符的形式给出的
    2.编译器会将它们转化为相应的ASCII码
    3.例如
        1.db &#39;unIX&#39;   ;相当于：db 75H,6EH,49H,58H
            &#39;u&#39;、&#39;n&#39;、&#39;I&#39;、&#39;X&#39;的ASCII码分别为75H,6EH,49H,58H
        2.mov al,&#39;a&#39;  ;相当于：mov al，61H
            &#39;a&#39;的ASCII码为61H
    4.ASCII码中，大写字母和小写字母之间的规律
        小写字母=大写字母+32
        小写字母=大写字母+20H
        大写字母从41H开始排，小写字母从61H开始排
</code></pre>
<table>
<thead>
<tr>
<th>大写</th>
<th>二进制</th>
<th>小写</th>
<th>二进制</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>01000001</td>
<td>a</td>
<td>01100001</td>
</tr>
<tr>
<td>B</td>
<td>01000010</td>
<td>b</td>
<td>01100010</td>
</tr>
<tr>
<td>C</td>
<td>01000011</td>
<td>c</td>
<td>01100011</td>
</tr>
<tr>
<td>D</td>
<td>01000100</td>
<td>d</td>
<td>01100100</td>
</tr>
</tbody></table>
<pre><code>7.4 大小写转换的问题
    1.方案一：
        1.识别出是该字节是表示一个的大写英文字符，还是小写的
            用于条件判断的汇编程序，目前还没有学到
        2.根据+20H 或者 -20H进行大小写转换
    2.方案二：
        1.若全部转化为大写，则将第5位置0
            and al,11011111B
        2.若全部转化为小写，则将第5位置1
            or  al,00100000B
7.5 [bx+常数]
    mov ax,[bx+200]的含义：
    1.将一个内存单元的内容送入ax，这个内存单元的长度为2字节，存放一个入一个子单元
      该字单元的偏移地址为bx中的数值加上200，段地址在ds中
    2.也可以写成
        1.mov ax,200[bx]
        2.mov ax,[bx].200
7.6 用[bx+idata]的方式进行数组的处理
    在codesg中填写代码，将datasg中定义的第一个字符串转化为大写，第二个字符串转化为小写
      1.我们观察datasg段中的两个字符串，一个的起始地址为0，另一个的起始地址为5
      2.我们可以将这两个字符串看作两个数组，一个从0地址开始存放，另一个从5开始存放
      3.我们可以用[0+bx]和[5+bx]的方式在同一个循环中定位这两个字符串中的字符
      4.注意这个数组的定位方式，对比C语言
        C语言的数组定位方式：a[i]，b[i]，  a、b是地址常量
        汇编语言的数组定位方式：0[bx],5[bx]
        所以：[bx+常数]的方式为高级语言实现数组提供了便利的机制
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;BaSiC&#x27;</span><br><span class="line">	db &#x27;MinIX&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:</span><br><span class="line">	mov ax,datasg</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx,0</span><br><span class="line">	</span><br><span class="line">	mov cx,5	;做5次循环</span><br><span class="line">circ:</span><br><span class="line">	mov al,[bx]</span><br><span class="line">	and al,11011111b</span><br><span class="line">	mov [bx],al</span><br><span class="line">	mov al,[bx+5];等价于mov al,5[bx];等价于mov al,[bx].5</span><br><span class="line">	or al,00100000b</span><br><span class="line">	mov 5[bx],al</span><br><span class="line">	inc bx</span><br><span class="line">	loop circ</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<pre><code>7.7 SI和DI
    已经学过的10个寄存器：AX、BX、CX、DX、DS、CS、SS、ES、IP、SP
    1.SI和DI是8086CPU中和bx功能相近的寄存器
        bx不够用，所以引进了SI和DI
    2.SI和DI（16位）不能够分成两个8位寄存器来使用【和bx的区别】
    3.下面三组指令实现了相同的功能
        1.mov bx,0
          mov ax,[bx]
        2.mov si,0
          mov ax,[si]
        3.mov di,0
          mov ax,[di]
    4.下面三组指令也实现了相同的功能
        1.mov bx,0
          mov ax,[bx+123]
        2.mov si,0
          mov ax,[si+123]
        3.mov di,0
          mov ax,[di+123]
    5.用寄存器SI和DI实现将字符串&#39;welcome to masm!&#39;复制到它后面的数据区中
        通常用ds:si指向要复制的源始字符串
        通常用ds:di指向要复制的目的空间
        **注意si、di是16位寄存器，循环中自增时，应该+2
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">	db &#x27;welcome to masm!&#x27;</span><br><span class="line">	db &#x27;................&#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov si,0</span><br><span class="line">	mov di,16</span><br><span class="line">	</span><br><span class="line">	mov cx,8</span><br><span class="line">circ:</span><br><span class="line">	mov ax,0[si]</span><br><span class="line">	mov [di],ax</span><br><span class="line">	inc di</span><br><span class="line">	inc di</span><br><span class="line">	inc si</span><br><span class="line">	inc si</span><br><span class="line">	loop circ</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<pre><code>7.8 [bx+si]和[bx+di]
    1.[bx+si]和[bx+di]的含义类似，我们以[bx+si]为例进行讲解
        [bx+si]表示一个内存单元，它的偏移地址为bx中的数值加上si中的数值
          它的偏移地址在ds中
    2.[bx+si]也可以写成[bx][si]
7.9 [bx+si+常数]和[bx+di+常数]
    1.以[bx+Si+常数]为例讲解
        [bx+si+常量]表示一个内存单元，偏移地址为bx的值+si的值+常数
    2.指令mov ax,[bx+si+常数]也可以写成如下形式
        1.mov ax,200[bx+si]
        2.mov ax,200[bx][si]
        3.mov ax,[bx].200[si]
7.10 不同的寻址方式的灵活应用
    1.总结几种定位内存的方法
        1.ds:[常数]   【直接寻址】
            用一个常量来表示地址，可用于直接定位一个内存单元
        2.[bx]      【寄存器间接寻址】
            用一个寄存器的值来表示内存地址，可以间接定位一个内存单元
        3.[bx+常数]   【？？】
            用一节寄存器的值和常量表示内存地址，可在一个起始地址的基础上用变量间接定位一个内存单元
        4.[bx+si]
        5.[bx+si+常数]
    2.编程，给定数据段data，将data段中每个单词的头一个字母改写成大写字母
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">	db &#x27;1. file         &#x27;</span><br><span class="line">	db &#x27;2. edit         &#x27;</span><br><span class="line">	db &#x27;3. search       &#x27;</span><br><span class="line">	db &#x27;4. view         &#x27;</span><br><span class="line">	db &#x27;5. options      &#x27;</span><br><span class="line">	db &#x27;6. help         &#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx,0</span><br><span class="line">	</span><br><span class="line">	mov cx,6</span><br><span class="line">circ:</span><br><span class="line">	mov al,[bx+3]</span><br><span class="line">	and al,11011111b</span><br><span class="line">	mov [bx+3],al</span><br><span class="line">	add bx,16</span><br><span class="line">	loop circ</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<pre><code>    3.编程，给定数据段data，将data段中的每个单词改为大写字母
      1.【loop指令cx-1之后，在判断是否为0】
      2.双重循环用汇编怎么实现？
        应该在每次开始内循环的时候，将外层循环的cx的值保存起来，
        在执行外层循环的loop指令前，在恢复外层循环的cx数值。
        **可以用寄存器来临时保存，也可以用栈空间（内存）保存【没有多余的寄存器】
            更好的方法是使用：栈
          1.使用寄存器实现
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">	db 4,4,6,4,7,4;单词的字母数</span><br><span class="line">	db &#x27;          &#x27;;补齐</span><br><span class="line">	db &#x27;1. file         &#x27;</span><br><span class="line">	db &#x27;2. edit         &#x27;</span><br><span class="line">	db &#x27;3. search       &#x27;</span><br><span class="line">	db &#x27;4. view         &#x27;</span><br><span class="line">	db &#x27;5. options      &#x27;</span><br><span class="line">	db &#x27;6. help         &#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx,16</span><br><span class="line">	mov si,0</span><br><span class="line">	mov di,0</span><br><span class="line">	</span><br><span class="line">	mov cx,6;外层循环6次</span><br><span class="line">outer:;外层循环</span><br><span class="line">	mov dx,cx;用寄存器将外层循环的次数保存，C语言中是用栈来保存的</span><br><span class="line">	</span><br><span class="line">	mov cx,0</span><br><span class="line">	mov cl,[di];内循环的次数	</span><br><span class="line">	inner:;内层循环</span><br><span class="line">		mov al,[bx][si+3]</span><br><span class="line">		and al,11011111b</span><br><span class="line">		mov [bx][si+3],al</span><br><span class="line">		inc si</span><br><span class="line">		loop inner</span><br><span class="line">	</span><br><span class="line">	add bx,16</span><br><span class="line">	mov si,0</span><br><span class="line">	inc di</span><br><span class="line">	mov cx,dx;恢复外层循环的次数</span><br><span class="line">	loop outer</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<pre><code>          2.使用栈实现【更好的方法】
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line">data segment</span><br><span class="line">	db 4,4,6,4,7,4;单词的字母数</span><br><span class="line">	db &#x27;          &#x27;;补齐</span><br><span class="line">	db &#x27;1. file         &#x27;</span><br><span class="line">	db &#x27;2. edit         &#x27;</span><br><span class="line">	db &#x27;3. search       &#x27;</span><br><span class="line">	db &#x27;4. view         &#x27;</span><br><span class="line">	db &#x27;5. options      &#x27;</span><br><span class="line">	db &#x27;6. help         &#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">	dw 1,2,3,4,5,6,7,8</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov ax,stack</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov sp,16</span><br><span class="line">	mov bx,16</span><br><span class="line">	mov si,0</span><br><span class="line">	</span><br><span class="line">	mov cx,6;外层循环6次</span><br><span class="line">outer:;外层循环</span><br><span class="line">	push cx;将外层循环的次数保存</span><br><span class="line">	</span><br><span class="line">	mov cx,0</span><br><span class="line">	mov cl,[di];内循环的次数	</span><br><span class="line">	inner:;内层循环</span><br><span class="line">		mov al,[bx][si+3]</span><br><span class="line">		and al,11011111b</span><br><span class="line">		mov [bx][si+3],al</span><br><span class="line">		inc si</span><br><span class="line">		loop inner</span><br><span class="line">	</span><br><span class="line">	add bx,16</span><br><span class="line">	mov si,0</span><br><span class="line">	inc di</span><br><span class="line">	pop cx;恢复外层循环的次数</span><br><span class="line">	loop outer</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h1 id="第八章-数据处理的两个基本问题-1"><a href="#第八章-数据处理的两个基本问题-1" class="headerlink" title="第八章 数据处理的两个基本问题"></a>第八章 数据处理的两个基本问题</h1><pre><code>本章对前面的所有内容是具有总结性的
计算机是进行数据处理、运算的机器，那么有两个基本的问题就包含在其中：
    1.处理的数据在什么地方？
    2.要处理的数据有多长？
  这两个问题，在机器指令中必须给以明确或隐含的说明，否则计算机就无法工作
8.1 bx、si、di、bp
    1.在8086CPU中，只有这4个寄存器（bx、bp、si、di）可以用在“[...]”
        中，用来进行内存单元的寻址
    2.在“[...]”中，这四个寄存器（bx、bp、si、di）可以单个出现，
        或者只能以以下4种组合出现
        1.bx和si
        2.bx和di
        3.bp和si
        4.bp和di
    3.错误的用法
        mov ax,[bx+bp]
        mov ax,[si+di]
    4.只要在[...]中使用寄存器bp，则指令中没有显性给出段地址，那么
        段地址就默认在ss中，比如：
        mov ax,[bp]       ax的值为栈空间中，偏移地址为bp的内存单元
        mov ax,[bp+常数]      
        mov ax,[bp+si]
        mov ax,[bp+si+常数]
8.2 机器指令处理的数据所在的位置
    1.绝大部分机器指令进行数据处理的指令大致可分为3大类
        读取、写入、运算
    2.在机器指令这一层，并不关心数据的值是多少，而关心指令执行前一刻
        它将要处理的数据所在的位置
    3.指令在执行前，所要处理的数据可以在三个地方
        CPU内部（寄存器）、内存、端口
8.3 汇编语言中数据位置的表达
    汇编语言中用三个概念来表达数据的位置
      1.立即数
      2.寄存器
      3.段地址（SA）和偏移地址（EA）
        1.存放段地址的寄存器可以是默认的，
            既可以是默认在ds中，也可以是在ss中（使用bp寄存器）
        2.存放段地址的寄存器也可以显性的给出
            mov ax,ds:[bp]
            mov ax,es:[bx]
            mov ax,ss:[bx+si]
            mov ax,cs:[bx+si+8]
8.4 寻址方式
</code></pre>
<p><img src="/img_ass/8.1.png" class="lazyload" data-srcset="/img_ass/8.1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="avatar"></p>
<pre><code>8.5 指令要处理的数据有多长？
    1.8086CPU的指令，可以处理两种尺寸的数据，byte和word
        所以在机器指令中要指明，指令进行的是字操作还是字节操作
    2.8086CPU确定数据长度的几种方法
        1.通过寄存器名指明要处理的数据的尺寸
            mov al,1        ;指明数据是字节型的
            mov bx,ds:[0]   ;指明数据是字型的
        2.在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度
            X在汇编指令中可以为word或byte
            1.下面的指令中，用byte ptr指明了指令访问的内存单元是字节型单元
              mov byte ptr ds:[0],1
              inc byte ptr [bx]
              inc byte ptr ds:[0]
              add byte ptr [bx],2
            2.下面的指令中，用word ptr指明了指令访问的内存单元是字型单元
              mov word ptr ds:[0],1
              inc word ptr [bx]
              inc word ptr ds:[0]
              add word ptr [bx],2
        3.其他方法
            有些指令默认了访问的内存单元类型
            pop、push指令，一定是字型数据
    3.在没有寄存器参与的内存单元访问指令中，用word ptr或者byte ptr
        显性地指明所要访问的内存单元的长度，是非常有必须要的
        否则，CPU无法得知所要访问的单元是字单元，还是字节单元
8.6 寻址方式的综合应用
8.7 div指令
    1.div是除法指令（division），使用div作除法的时候，要求
        1.除数：8位或16位，在寄存器或内存单元中
        2.被除数：（默认）放在AX或DX和AX中
        3.除数与被除数的相互关系
            除数  被除数
            8位   16位（AX）
            16位  32位（DX+AX）
        4.结果存放的位置
            运算  8位  16位
            商    AL   AX
            余数  AH   DX
    2.div指令格式
        1.div 寄存器
        2.div 内存单元
        除数是寄存器或内存单元的内容
    3.div指令示例
        1.div byte ptr ds:[0]   ;被除数是16位，除数是ds:[0]的内容(8位)
          含义：(al)=(ax)/((ds)*16+0)的商
               (ah)=(ax)/((ds)*16+0)的余数
       2.div word ptr es:[0]    ;被除数是32位，除数是es:[0]的内容(16位)
          含义：(ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商
               (dx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数   
    4.利用除法指令计算100001/100
        1.被除数100001大于65535，要使用dx和ax两个寄存器联合存放
          即说要进行的16位的除法
        2.除数100小于255，可以在一个8位寄存器中存放，但是，因为被除数是32位
          除数应为16位，所以要用16位寄存器来存放除法100
        3.现将100001表示成十六进制数：186A1H，即dx中存放1H，ax中存放86A1H
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov dx,1</span><br><span class="line">mov ax,86A1H</span><br><span class="line">mov bx,100</span><br><span class="line">div bx  ;默认除数是16位的</span><br></pre></td></tr></table></figure>
<pre><code>8.8 伪指令dd
    1.dd是用来定义双字型数据的
    2.示例
        data segment
            db 1    ;字节型数据
            dw 1    ;字型数据
            dd 1    ;双字型数据
        data ends
    3.已知data段数据，用div计算data中第一个数据除以第二个数据后的结果，
        商存放在第3个数据的内存单元中
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">	dd 100001</span><br><span class="line">	dw 100</span><br><span class="line">	dw 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov ax,[bx]     ;低位存放在ax中</span><br><span class="line">	mov dx,[bx+2]   ;高位存放在dx中</span><br><span class="line">	div word ptr [bx+4]</span><br><span class="line">	mov [bx+6],ax   ;商存放在ax中，把ax中的内容放入内存中</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<pre><code>8.9 dup
    1.dup是一个操作符，在汇编语言中，同db、dw、dd等一样，也是有编译器识别处理的符号
    2.dup和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复
    3.dup示例
        1.db 3 dup(0)   ;定义了3个字节，他们的值都是0
        2.db 3 dup(0,1,2)   ;定义了9个字节，他们是0、1、2、0、1、2、0、1、2
        3.db 3 dup(&#39;abc&#39;,&#39;ABC&#39;) ;定义了18个字节，相当于db&#39;abcABCabcABCabcABC&#39;
    4.dup的使用格式
        db 重复的次数 dup(重复的字节型数据)
        dw 重复的次数 dup(重复的字型数据)
        dd 重复的次数 dup(重复的双字型数据)
【实验七】
没调试成功
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack,es:table</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">	;空栈时，sp指向16</span><br><span class="line">	dw 8 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	;表示21年的21个字符串</span><br><span class="line">	;起始地址0，终止地址21*4-1：83</span><br><span class="line">	db &#x27;1975&#x27;,&#x27;1976&#x27;,&#x27;1977&#x27;,&#x27;1978&#x27;,&#x27;1979&#x27;,&#x27;1980&#x27;,&#x27;1981&#x27;,&#x27;1982&#x27;,&#x27;1983&#x27;</span><br><span class="line">	db &#x27;1984&#x27;,&#x27;1985&#x27;,&#x27;1986&#x27;,&#x27;1987&#x27;,&#x27;1988&#x27;,&#x27;1989&#x27;,&#x27;1990&#x27;,&#x27;1991&#x27;,&#x27;1992&#x27;</span><br><span class="line">	db &#x27;1993&#x27;,&#x27;1994&#x27;,&#x27;1995&#x27;</span><br><span class="line"></span><br><span class="line">	;表示21年公司总收入的21个双字型数据</span><br><span class="line">	;起始地址21*4：84，终止地址21*4+21*4-1：167</span><br><span class="line">	dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514</span><br><span class="line">	dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000</span><br><span class="line"></span><br><span class="line">	;表示21年公司雇员人数的21个字型数据</span><br><span class="line">	;起止地址21*8：168，终止地址21*8+21*2-1：209</span><br><span class="line">	dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226</span><br><span class="line">	dw 11542,14430,15257,17800</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">table segment</span><br><span class="line">	db 21 dup(&#x27;year summ ne ?? &#x27;)</span><br><span class="line">table ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	</span><br><span class="line">	mov ax,table</span><br><span class="line">	mov es,ax</span><br><span class="line">	</span><br><span class="line">	mov ax,stack</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov sp,16</span><br><span class="line">	</span><br><span class="line">	mov si,0</span><br><span class="line">	mov di,0</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov bp,0 </span><br><span class="line">	</span><br><span class="line">	mov cx,21</span><br><span class="line">outer:</span><br><span class="line"></span><br><span class="line">	push si</span><br><span class="line">	add si,si</span><br><span class="line">	mov ax,ds:[bp]</span><br><span class="line">	mov es:[bx][di],ax</span><br><span class="line">	mov ax,ds:84[bp]</span><br><span class="line">	mov es:[bx][di+5],ax</span><br><span class="line">	pop si</span><br><span class="line">	mov al,168[si]</span><br><span class="line">	mov es:[bx][di+10],al</span><br><span class="line">	inc si</span><br><span class="line">	add di,2</span><br><span class="line">	push si</span><br><span class="line">	add si,si</span><br><span class="line">	mov ax,ds:[bp]</span><br><span class="line">	mov es:[bx][di],ax</span><br><span class="line">	mov ax,ds:84[bp]</span><br><span class="line">	mov es:[bx][di+5],ax</span><br><span class="line">	pop si</span><br><span class="line">	mov al,168[si]</span><br><span class="line">	mov es:[bx][di+10],al</span><br><span class="line">	inc si</span><br><span class="line">	add di,2</span><br><span class="line">	</span><br><span class="line">	add bx,16</span><br><span class="line">	loop outer</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h1 id="第九章-转移指令的原理-1"><a href="#第九章-转移指令的原理-1" class="headerlink" title="第九章 转移指令的原理"></a>第九章 转移指令的原理</h1><pre><code>8086CPU的转移指令分为以下几类：
    1.无条件跳转指令（如：jmp）
    2.条件跳转指令
    3.循环指令（如：loop）
    4.过程，就像C语言中的函数
    5.中断
9.1 操作符offset
    操作符offset在汇编语言中由编译器处理，它的功能是取标号的偏移地址
    如：s:mov ax,offset s
9.2 jmp指令
    1.无条件转移，可以只修改ip，也可以同时修改cs和ip
        1.【jmp 段地址:偏移地址】  可以用来同时修改CS和IP
            指令中的段地址修改CS
            偏移地址修改IP
            这种用法编译器不认识，只能做在debug中使用
        2.【jmp 某一合法的寄存器】   仅修改IP的内容
            比如：jmp ax 或者 jmp bx（类似于mov IP ax）
    2.jmp指令要给出两种信息：
        1.转移的目的地址
        2.转移的距离（段间转移、段内短转移、段内近转移）
9.3 依据位移进行转移的jmp指令
    1.jmp short 标号【转到标号处执行指令,段内短转移】
      此格式实现的是：段内短转移，它对ip的修改范围为-128~127
    2.也就是说，它向前转移时可以最多越过128个字节，负数使用补码表示
      向后转移可以最多越过127个字节
    3.CPU不需要目的地址就可以实现对ip的修改
        jmp指令的机器码中不包含目的地址，但是可以实现跳转
        实现的方式，是在原地址的基础上进行一个偏移量，即位移
    4.还有一种和指令“jmp short 标号”功能类似的指令格式：
        jmp near ptr 标号，它实现的是段内近转移 
        功能为：(ip)=(ip)+16位位移
        jmp short 标号是8位的位移，而jmp near ptr 标号是16位位移
9.4 转移的目的地址在指令中的jmp指令
    前面讲的jmp指令，其对应的机器码中并没有转移的目的地址，而是相对于当前ip的转移位移
    1.指令“jmp far ptr 标号”
        实现的是段间转移，又称为远转移,这时机器码中应该明确给出【段地址】
    2.指令“jmp far ptr 标号”功能如下：
        (CS)=标号所在段的段地址
        (IP)=标号所在段中的偏移地址
        far ptr 指明了指令用标号的段地址和偏移地址修改cs和ip
9.5 转移地址在寄存器中的jmp指令
    指令格式：jmp 16位寄存器
    功能：修改ip寄存器中的值，把16位寄存器中的值送入到ip寄存器中
9.6 转移地址在内存中的jmp指令
    转移地址在内存中的jmp指令有两种格式：
    1.jmp word ptr 内存单元地址（段内转移）
        功能：将内存中的那个字视为一个偏移地址，然后跳转到那个偏移地址
        与【jmp 寄存器】功能相似
        内存单元地址可用寻址方式的任意格式给出
    2.jmp dword ptr 内存单元地址（段间转移）
        (ip)=(内存单元地址)   ;双字中的低位字是给ip的
        (cs)=(内存单元地址+2) ;双字中的高位字是给cs的
        跟【jmp 段地址:偏移地址】功能类似
        内存单元地址可用寻址方式的任意格式给出
        **补充：不能直接向内存单元中加入立即数
            要通过寄存器，把立即数加进去
9.7 jcxz指令
    1.有条件跳转指令，所有的有条件跳转指令都是短转移
        对应的机器码中包含转移的位移，而不是目的地址。对ip的修改范围都为：-128~127
        **另一个有条件跳转指令【loop指令】
    2.指令格式：jcxz 标号
        如果（cx）=0，则跳转到标号处执行
    3.jcxz 标号 指令的操作：
        1.当(cx)=0时，(ip)=(ip)+8位位移
        2.当(cx)!=0时，什么也不做（程序继续向下执行）
9.8 loop指令
    1.循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移
    2.指令格式：loop 标号
    3.指令的内部操作
        1.cx=cx-1
        2.如果cx!=0，(ip)=(ip)+8位位移，跳转
        3.(cx)=0，什么也不做，程序向下执行
        cx用来控制循环的次数
9.9 根据位移进行转移的意义
    1.根据位移进行转移，这样设计，方便了程序段在内存中的浮动装配
        可以实现代码的复用
    2.如果在机器码中直接给出【段地址:偏移地址】，
        这段程序在内存中换一个位置，则会运行不正确
    3.段内近转移、段内短转移都是根据位移进行转移，一共有四种方式
        1.jmp short ptr 标号
        2.jmp near ptr 标号
        3.jcxz 标号
        4.loop 标号
9.10 编译器对转移位移超界的检测
    注意，根据位移进行转移的指令，他们的转移范围会受到限制
    如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错
【实验八、九】【这个实验要重点看】
</code></pre>
<h1 id="第十章-call和ret指令-1"><a href="#第十章-call和ret指令-1" class="headerlink" title="第十章 call和ret指令"></a>第十章 call和ret指令</h1><pre><code>call和ret指令都是转移指令，它们都能修改ip，或同时修改cs和ip
10.1 ret和ref
    1.ret指令用栈中的数据，修改ip的内容，从而实现【近转移】
        CPU执行ret指令时，进行下面两步操作：
        1.(ip)=((ss)*16+(sp))   ;ip的值修改为栈顶的内容
        2.(sp)=(sp)+2           ;栈顶移动
    2.retf指令用栈中的数据，修改cs和ip的内容，从而实现【远转移】
        CPU执行retf指令时，进行下面四步操作
        1.(ip)=((ss)*16+(sp))   ;ip的内容修改为栈顶的内容
        2.(sp)=(sp)+2           ;栈顶移动
        3.(cs)=((ss)*16+(sp))   ;cs的内容修改为栈顶移动之后，栈顶的内容
        4.(sp)=(sp)+2           ;栈顶移动
        栈顶的两个字，低位字修改为ip，高位字修改为cs
    3.可以看出，如果我们用汇编语法来解释ret和retf指令，则
        1.CPU执行ret指令，相当于
            pop ip
        2.执行retf指令时，相当于
            pop ip
            pop cs
10.2 call指令
    1.call指令经常跟ret指令配合使用，因此CPU执行call指令，进行两步操作：
        1.将当前的ip或cs和ip压入栈中
        2.转移
    2.call指令不能实现短转移，除此之外，
        call指令实现转移的方法和jmp指令的原理相同
    【依据位移进行转移的call指令】
    3.CPU执行“call 标号”这种格式的call指令时，进行如下操作：
        1.(sp)=(sp)-2         ;栈顶移动
        2.((ss)*16+(sp))=(ip) ;当前ip内容压栈
        3.(ip)=(ip)+16位位移   ;跳转到标号处
    4.call指令格式：call 标号
        相当于执行：
        push ip
        jmp near ptr 标号
10.4 转移的目的地址在指令中的call指令
    1.指令格式：call far ptr 标号
        实现的是段间转移
    2.执行这种格式的call指令时CPU的操作
        1.(sp)=(sp)-2           ;栈顶移动
        2.((ss)×16+(sp))=(cs)   ;先把cs压栈
        3.(sp)=(sp)-2           ;栈顶移动
        4.((ss)×16+(sp))=(ip)   ;然后把ss压栈
    3.CPU执行“call far ptr 标号”时，相当于进行
        push cs
        push ip
        jmp far ptr 标号
10.5 转移地址在寄存器中的call指令
    1.指令格式：call 16位寄存器
    2.执行这种指令时，在CPU中的操作
        1.(sp)=(sp)-2
        2.((ss)×16+(sp))=(ip)
        3.(ip)=(16位寄存器)
    3.相当于
        push ip
        jmp 16位寄存器
10.6 转移地址在内存中的call指令
    转移地址在内存中的call指令有两种格式：
    1.call word ptr 内存单元地址
        汇编语法解释
          push ip
          jmp word ptr 内存单元地址
    2.call dword ptr 内存单元地址
        汇编语法解释
          push cs   ;cs存放在高位
          push ip   ;ip存放在低位
          jmp dword ptr 内存单元地址
10.7 call和ret的配合使用
10.8 mul指令
    相乘的两个数；要么都是8位，要么都是16位
    1.8位：AL中和8位寄存器或内存字节单元中
        AL中的内容作为被乘数
        结果放在AX中
    2.16位：AX中和16位寄存器或内存字单元中
        AX中的内容作为被乘数
        结果放在DX（高位）和AX（低位）中。
    3.格式如下：
        mul 寄存器
        mul 内存单元（byte ptr或 word ptr指明是字还是字节）
10.9 模块化程序设计
10.10 参数和结果传递的问题
    【编程】计算data段中第一组数据的3次方，结果保存在后面一组dword单元中
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data sgement</span><br><span class="line">    dw 1,2,3,4,5,6,7,8</span><br><span class="line">    dd 0,0,0,0,0,0,0,0 </span><br><span class="line">data ends</span><br></pre></td></tr></table></figure>
<pre><code>10.11 批量数据的传递
    使用寄存器、内存、栈传递数据
    【编程】将一个全是字母，以0结尾的字符串，转化为大写
【实验十 编写子程序】
    1.显示字符串
    2.解决除法溢出问题
    3.数值显示
【课程设计1】
</code></pre>
<h1 id="第十一章-标志寄存器-1"><a href="#第十一章-标志寄存器-1" class="headerlink" title="第十一章 标志寄存器"></a>第十一章 标志寄存器</h1><pre><code>8086CPU的标志寄存器有16位，其中存储的信息通常被称为程序状态字（PSW）
本章中的标志寄存器（以下简称为flag）是我们要学习的最有一个寄存器
flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息
8086CPU的flag寄存器的结构：
    1.flag的1、3、4、12、13、14、15位共7位在8086CPU中没有使用，不具有任何含义
        而0、2、4、6、7、8、9、10、11位共9位都具有特殊的含义
    2.示意图
</code></pre>
<p><img src="/img_ass/11.1.png" class="lazyload" data-srcset="/img_ass/11.1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="avatar"></p>
<pre><code>11.1 ZF标志
    1.flag的第6位是ZF，零标志位。
        它记录相关指令执行后，
          1.结果为0，ZF=1
          2.结果不为0，ZF=0
    2.示例：
        mov ax,1
        sub ax,1
        指令执行后，结果为0，则ZF=1
        mov ax，2
        sub ax，1
        指令执行后，结果不为0，则ZF=0
    3.注意，在8086CPU的指令集中，有的指令的执行会影响标志寄存器
        比如：add、sub、mul、div、inc、or、and等
        他们大都是运算指令（逻辑运算或者算术运算）
      有的指令的执行对标志寄存器没有影响，
        比如：mov、push、pop等，他们大都是传送指令
11.2 PF标志
    flag的第2位是PF，奇偶标志位
    它记录指令执行后，结果的所有二进制位中1的个数
      1.为偶数，PF=1
      2.为奇数，PF=0
11.3 SF标志
    1.flag的第7位是SF，符号标志位
    2.它记录指令执行后
      1.结果为负。sf=1
      2.结果为正，sf=0
      sf标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负
        sf标志把所有数当作有符号数
        如果把数据当作无符号数运算，sf的值则没有意义，虽然相关指令会影响它的值
    3.也就是说，CPU在执行add等指令时，是必然要影响sf标志位的值
        至于我们需不需要这种影响，那就看我们如何看待指令所进行的运算    
11.4 CF标志   
    1.flag的第0位是CF，进位标志位
      一般请况下，在进行无符号数运算的时候，
        它记录了运算结果的最高有效位向更高位的进位值，
          或从更高位的借位值
        代表假想的更高位
    2.CPU在运算时，不会丢弃进位值，而是记录在一个特殊的寄存器的某一位上
        8086CPU就用flag的cf为来记录这个进位值，借位也一样
    3.在debug中的显示
</code></pre>
<p><img src="/img_ass/11.2.png" class="lazyload" data-srcset="/img_ass/11.2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="avatar"></p>
<pre><code>    4.无符号的时候产生的结果
11.5 OF标志
    flag中的第11位
    进行有符号数运算的时候，如果结果超过了机器所能表示的范围称为溢出
    1.这里所讲的溢出，只是对有符号数运算而言
      就像进位只是相对于无符号数而言！
    2.一定要注意cf和of的区别
        当需要把机器码看成有符号数则使用of
        当需要把机器码看成无符号数则使用cf
11.6 adc标志
    adc是带进位的加法指令，他利用了cf上记录的进位值
    1.格式：adc 操作对象1，操作对象2
    2.功能：操作对象1=操作对象1+操作对象2+cf
      比如：adc ax,bx实现的功能是：
        (ax)=(ax)+(bx)+cf
    3.执行adc指令的时候，加上的cf的值的含义，由adc指令前的指令决定
        也就是说，关键在于所加上的cf值是被什么指令设置的
    4.如果cf是被sub指令设置的，那么他的含义就是借位值
      如果是被add指令设置的，那么它的含义就是进位值
    5.下面的指令和add ax,bx具有相同的结果
        add al,bl
        adc ah,bh
        CPU提供adc指令的目的，就是来进行加法的第二步运算的
        adc指令和add指令相配合就可以对更大的数据进行加法运算
    【实验：编程计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中】
11.7 sbb标志
    sbb是带借位减法指令，他利用了cf位上记录的借位值
    1.格式：sbb 操作对象1，操作对象2
    2.功能：操作对象1=操作对象1-操作对象2-cf
    3.利用sbb指令，我们可以对任意大的数据进行减法运算
    4.sbb和adc是基于相同的思想设计的两条指令，
        在应用思路上和adc类似
11.8 cmp标志
    1.cmp是比较指令，功能相当于减法指令，只是不保存结果
    2.cmp指令执行后，将对标志寄存器产生影响
    3.其他相关指令通过识别这些被影响的标志寄存器，来得知比较结果
    4.cmp指令格式：cmp 操作对象1,操作对象2
    5.功能：计算操作对象1-操作对象2，但并不保存结果，仅仅根据计算结果对标志寄存器进行设置
    6.比如：cmp ax,ax
        做(ax)-(ax)的运算，结果为0，但并不在ax中保存，仅影响flag的相关位
        指令执行后
        zf=1    ;结果为0
        pf=1    ;结果的1的个数为偶数
        sf=0    ;结果为正号
        cf=0    ;结果没有产生进位或借位
        of=0    ;结果没有溢出
    7.根据flag，判断cmp指令的结果（无符号数）
</code></pre>
<p><img src="/img_ass/11.3.png" class="lazyload" data-srcset="/img_ass/11.3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="avatar"></p>
<pre><code>    8.cmp既可以对无符号数进行比较，也可以对有符号数进行比较
        cmp 操作数1,操作数2   ;操作数1、操作数2都是有符号数
        1.of=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负
            of=0，sf=1   则 操作数1比操作数2小
            of=0，sf=0   则 操作数1比操作数2大
        2.of=1，说明有溢出，逻辑上真正结果的正负与实际结果的正负相反
            of=1，sf=1   则 操作数1比操作数2大
            of=1，sf=0   则 操作数1比操作数2小
11.9 检测比较结果的条件转移指令
    1.这些条件转移指令通常和cmp相配合使用
    2.因为cmp指令可以同时进行两种比较，无符号数和有符号数的比较
      所以，这些转移指令也分为两种，即：
        1.根据【无符号数】的比较结果进行转移的条件转移指令，
          他们检测zf、cf的值
        2.根据【有符号数】的比较结果进行转移的条件转移指令
          他们检测sf、of和zf的值
    3.无符号比较，条件转移指令小结【无符号，6个】
      1.je  等于则转移     zf=1
      2.jne 不等于则转移   zf=0
      3.jb  低于则转移     cf=1      【b表示below】
      4.jnb 不低于则转移   cf=0
      5.ja  高于则转移     cf=0，zf=0【a表示above】
      6.jna 不高于则转移   cf=1或zf=1
11.10 DF标志和串传送指令
    1.flag的第10位DF，方向标志位
        在串处理指令（movsb，movsw）中，控制每次操作后si、di的增减
        df=0：每次操作后si，di递增
        df=1：每次操作后si，di递减
    2.格式：movsb
    3.功能：（以字节为单位传送）
        1.((es)*16+(di))=((ds)*16+(si))
        2.如果df=0，则：(si)=(si)+1
                       (di)=(di)+1
          如果df=1，则：(si)=(si)-1
                       (di)=(di)-1
        3.功能文字描述
            movsb的功能是将ds:si指向的内存单元中的字节
            送入es:di中，然后根据标志寄存器df位的值，
              将si和di递增或递减
    4.movsw 传送一个字
    5.movsb和movsw都和rep配合使用
        格式：rep movsb
        rep的作用根据cx的值，重复执行后面的串传送指令
    6.cld指令和std指令
        cld指令：将标志寄存器的df置为0【c:clear】
        std指令：将标志寄存器的df置为1【s:set】
11.11 pushf和popf
    pushf：将标志寄存器的值压栈
    popf：从栈中弹出数据，送入标志寄存器中
    pushf和popf为直接访问标志寄存器提供了一种方法
11.12 标志寄存器在debug中的表示
</code></pre>
<h1 id="第十二章-内中断-1"><a href="#第十二章-内中断-1" class="headerlink" title="第十二章 内中断"></a>第十二章 内中断</h1><pre><code>**引言和简介
    1.中断是CPU处理外部突发事件的一个重要技术
    2.它能使CPU在运行过程中对外部事件发出的中断请求及时地进行处理，处理完成后
        又立即返回断点，继续进行CPU原来的工作。
    3.引起中断的原因【即：发出中断请求的来源叫作中断源】
    4.根据中断源的不同，可以把中断分为：【软件中断】和【硬件中断】两大类
        而硬件中断又可以分为【外部中断】和【内部中断】两类
12.1 内中断的产生
    1.外部中断一般是指计算机外设发出的中断请求，如：键盘中断、打印机中断、定时器中断。
        外部中断是可以屏蔽的中断，也就是说，利用中断控制器可以屏蔽这些外部设备的中断请求。
    2.内部中断是指因硬件出错（如突然掉电、奇偶校验错等）或运算出错（除数为零、运算溢出、单步中断）所引起的中断。
        内部中断是不可屏蔽的中断
    3.软件中断其实并不是真正的中断，他们只是可被调用执行的一般程序，
        DOS的系统功能调用（int 21h）都是软件中断
    4.CPU为了处理并发的中断请求，规定了中断的优先权，优先权由高到低的顺序是：
        1.除法错、溢出中断、软件中断
        2.不可屏蔽中断
        3.可屏蔽中断
        4.单步中断
12.2 中断处理程序简介
    1.CPU的设计者必须在中断信息和其处理程序的入口地址之间建立某种联系
        使得CPU根据中断信息可以找到要执行的处理程序。
    2.中断信息中包含有表示中断的类型码。根据CPU的设计，中断类型码的作用就是用来定位中断处理程序的。
    3.CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址
        即中断类型码是中断向量在中断向量表中的索引
12.3 中断向量表【中断向量表就是中断向量的列表】
    1.中断向量表在内存中保存，其中存放着256个【2^8,8位中断类型码】中断源所对应的中断处理程序的入口
        对于8086PC机，中断向量表指定放在内存地址0处
    2.从0:0-0:03ffh的1024个字节【256*4，物理地址使用段地址和偏移地址存放，需要4个字节】中存放着中断向量表
12.4 中断过程
    1.可以用中断类型码，在中断向量表中找到中断处理程序的入口
        找到这个入口地址的最终目的是用它设置cs和ip，使CPU执行中断处理程序
    2.用中断类型码找到中断向量，并用它设置cs和ip，这个工作时由CPU的硬件自动完成的
        CPU硬件完成这个工作的过程被称为【中断过程】
    3.中断过程
        8086CPU的中断过程
        1.（从中断信息中）取得中断类型码
        2.标志寄存器的值入栈（保护标志位）
        3.设置标志寄存器的第8位TF和第9位IF设置为0（后面讲解本步的目的）
        4.cs内容入栈
        5.ip内容入栈
        6.从内存地址为中断类型码*4和中断类型码*4+2的两个子单元中
            读取中断处理程序的入口地址设置cs和ip
    4.使用汇编语言描述中断过程，如下
        1.取得中断类型码N
        2.pushf
        3.TF=0，IF=0
        4.push cs
        5.push ip
        6.（ip）=（N*4），（cs）=（N*4+2）
12.5 中断处理程序
    1.由于CPU随时都可能检测到中断信息，也就是说，CPU随时都可能执行中断处理程序，
        所以，中断处理程序必须一致存储在内存某段空间中
    2.而中断处理程序的入口地址，即【中断向量】，必须存储在对应的中断向量表表项中
    3.中断处理程序的编写方法和子程序的比较类似，下面是常规的步骤
        1.保存用到的寄存器
        2.处理中断
        3.恢复用到的寄存器
        4.用iret指令返回
        **iret指令的功能用汇编语法描述为
            pop ip
            pop cs
            popf
          iret通常和硬件自动完成的中断过程配合使用
          iret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序
12.6 除法错误中断的处理
    当CPU执行div等除法指令的时候，如果发生了除法溢出错误，将产生中断类型码为0的终端信息
    CPU将检测到这个信息，然后引发中断程序，转去执行0号中断对应的中断处理程序
    例如：
        mov ax 1000h
        mov bh，1
        div bh
      此程序会产生溢出
      运行之后，会显示
</code></pre>
<p><img src="/img_ass/12.1.png" class="lazyload" data-srcset="/img_ass/12.1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="avatar"></p>
<pre><code>12.7 编程处理0号中断
    现在重新编写一个0号中断处理程序，它的功能是在屏幕中间显示“Welcome to here!”的广告词，然后返回到操作系统
    把中断处理程序放到安全空间中
    中断程序的框架
</code></pre>
<p><img src="/img_ass/12.2.png" class="lazyload" data-srcset="/img_ass/12.2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="avatar"></p>
<pre><code>12.8 安装
    计算中断程序的长度：offset 标号1-offset 标号2
    在代码段中存放数据        
12.9 do0
12.10 设置中断向量
12.11 单步中断
    如果检测到标志寄存器的tf位为1，则产生单步中断，引发中断过程
12.12 响应中断的特殊情况
</code></pre>
<p><img src="/img_ass/12.3.png" class="lazyload" data-srcset="/img_ass/12.3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="avatar"><br><img src="/img_ass/12.4.png" class="lazyload" data-srcset="/img_ass/12.4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="avatar"></p>
<h1 id="第十三章-int指令-1"><a href="#第十三章-int指令-1" class="headerlink" title="第十三章 int指令"></a>第十三章 int指令</h1><pre><code>13.1 int指令
    1.int格式：int n  ;n为中断类型码
        它的功能是引发中断过程
    2.CPU执行int n指令，相当于引发一个n号中断的中断过程，执行过程如下
        1.取中断类型码
        2.标志寄存器入栈，if=0，tf=0
        3.cs，ip入栈
        4.从此处转去执行n号中断的中断处理过程
    3.可以在程序中使用int指令调用任何一个中断的中断处理程序
        可以用int指令调用这些子程序，也可以自己编写一些中断处理程序供别人使用
13.2 编写供应用程序调用的中断例程
    【实例1】编写、安装中断7ch的中断例程，实现求一个word型数据的平方
        1.功能：求一word型数据的平方
        2.参数：（ax）=要计算的数据
        3.返回值：dx、ax中存放结果的高16位和低16位
        4.应用举例：求2*3456^2
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">;程序1：调用中断程序计算平方</span><br><span class="line">code segment</span><br><span class="line">    assume cs: code</span><br><span class="line">start:</span><br><span class="line">    mov ax,3456; (ax)=3456</span><br><span class="line">    int 7ch;调用中断7ch的中断例程，计算ax中的数据的平方</span><br><span class="line">    </span><br><span class="line">    add ax,ax</span><br><span class="line">    adc dx,dx ;存放结果，讲结果乘以2</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line">;程序2：编写中断程序</span><br><span class="line">;程序2中要做三部分工作</span><br><span class="line">;   1.编程实现求平方功能的程序</span><br><span class="line">;   2.安装程序，我们将其安装在0:200处</span><br><span class="line">;   3.设置中断向量表，将程序的入口地址保存在7ch表项中，使其成为中断7ch的中断例程。</span><br><span class="line">code segment</span><br><span class="line">    assume cs:code</span><br><span class="line">start:</span><br><span class="line">    mov ax,cs</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov si,offset sqr					;设置ds:si指向源地址</span><br><span class="line">    mov ax,0</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,200h							;设置es:di指向目的地址</span><br><span class="line">    mov cx,offset sqrend - offset sqr	;设置cx为传输长度</span><br><span class="line">    cld									;设置传输方向为正</span><br><span class="line">    rep movsb</span><br><span class="line"></span><br><span class="line">    mov ax,0</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov word ptr es:[7ch*4],200h        ;设置中断向量地址，偏移地址</span><br><span class="line">    mov word ptr es:[7ch*4+2],0         ;设置中断向量地址，段地址</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line">  sqr:  </span><br><span class="line">		mul ax</span><br><span class="line">		iret</span><br><span class="line">sqrend:	nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<pre><code>    【实例2】编写、安装中断7ch的中断例程，实现将一个全是字母，以0结尾的字符串，转化为大写。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">code segment</span><br><span class="line">    assume cs:code</span><br><span class="line">start:</span><br><span class="line">    mov ax,cs</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov si,offset capital</span><br><span class="line">    mov ax,0</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,200h</span><br><span class="line">    mov cx,offset capitalend - offset capital</span><br><span class="line">    cld</span><br><span class="line">    rep movsb</span><br><span class="line"></span><br><span class="line">    mov ax,0</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov word ptr es:[7ch*4],200h</span><br><span class="line">    mov word ptr es:[7ch*4+2],0</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line">capital:</span><br><span class="line">    push cx</span><br><span class="line">    push si</span><br><span class="line">		</span><br><span class="line">change: </span><br><span class="line">    mov cl,[si]</span><br><span class="line">    mov ch,0</span><br><span class="line">    jcxz ok</span><br><span class="line">    and byte ptr [si],11011111b</span><br><span class="line">    inc si</span><br><span class="line">    jmp short change</span><br><span class="line">ok:	</span><br><span class="line">    pop si</span><br><span class="line">    pop cx</span><br><span class="line">    iret</span><br><span class="line">		</span><br><span class="line">capitalend:</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<pre><code>13.3 对int、iret和栈的深入理解
    【问题】用7ch中断例程完成loop指令的功能
        不要随便修改sp，可以使用bp进行间接访问
13.4 BIOS和DOS所提供的中断例程
13.5 BIOS和DOS中断例程的安装过程
    1.开机后，CPU一加电，初始化（cs）=0ffffh，ip=0，自动从ffff:0单元开始执行程序
        ffff:0处有一条跳转指令，CPU执行该指令后，转去执行bios中的硬件系统的检测和初始化程序。
    2.初始化程序将建立bios所支持的中断向量，即将bios提供的中断例程的入口地址登记在中断向量表中。
    3.硬件系统检测和初始化完成后，调用19h进行操作系统的引导。从此将计算机交由操作系统控制。
    4.DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量
13.6 BIOS中断例程的应用
    1.int 10h中断例程是bios提供的中断例程，其中包含了多个和屏幕输出相关的子程序
        一般来说，一个供程序员调用的中断例程中，往往包括多个子程序，中断例程内部用传递进来的参数来决定执行哪个子程序
    2.bios和dos提供的中断例程，都用ah来传递内部子程序的编号
13.7 DOS中断例程应用
    int 21h中断例程是dos提供的中断例程，其中包含了dos提供给程序员造编程时调用的子程序
    【实验13】
**介绍一本汇编语言的书《The Art of Assembly Language》
</code></pre>
<h1 id="第十四章-端口-1"><a href="#第十四章-端口-1" class="headerlink" title="第十四章 端口"></a>第十四章 端口</h1><pre><code>CPU可以直接读写3个地方的数据
    1.CPU内部的寄存器
    2.内存单元
    3.端口
14.1 端口的读写
    1.对端口的读写不能用mov、push、pop等内存读写指令
        端口的读写指令只有两条：【in】和【out】分别用于从端口读取数据和往端口写入数据
    2.CPU执行内存访问指令和端口访问指令时，总线上的信息：
        1.访问内存
            mov ax,ds:[8];
            假设执行前（ds）=0
            执行时，与总线相关的操作：
            1.CPU通过地址线将地址信息8发出
            2.CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据
            3.存储器将8号单元中的数据通过数据线送入CPU
        2.访问端口
            这里的【端口】是对硬件开放的端口
            in al,60h; 从60h号端口读入一个字节
            执行时与总线相关的操作
            1.CPU通过地址线将地址信息60h发出
            2.CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据
            3.端口所在的芯片将60h端口中的数据通过数据线送入CPU
            **注意：在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据
                访问8位端口时用al，访问16位端口时用ax
        3.对0-255以内的端口进行读写
            in al,20h       ;从20h端口读一个字节
            out 20h,al      ;往20h端口写一个字节
        4.对256-65535的端口进行读写时，端口号放在【dx】中
            mov dx,3f8h     ;将端口号3f8送入dx
            in al,dx        ;从3f8h端口读一个字节
            out dx,al        ;从3f8h端口写一个字节
14.2 CMOS RAM芯片
    1.PC机中有一个CMOS RAM芯片，其有如下特征
        1.包含一个实时钟和一个有128个存储单元的RAM存储器。（早期的计算机为64字节）
        2.该芯片靠电池供电。因此，关机后其内部的实时钟仍可以正常工作，RAM中的信息不丢失
        3.128字节的RAM中，内部实时钟占用0-0dh单元来保存时间信息，其余大部分分单元用于
            保存系统配置信息，供系统启动时bios程序读取
            bios也提供了相关的程序，使我们可以在开机的时候配置CMOS RAM中的系统信息
        **补充：BIOS
            BIOS是英文&quot;Basic Input Output System&quot;的缩略词，直译过来后中文名称就是&quot;基本输入输出系统&quot;。
              在IBM PC兼容系统上，是一种业界标准的固件接口。BIOS这个字眼是在1975年第一次由CP/M操作系统中出现。
              BIOS是个人电脑启动时加载的第一个软件
        4.该芯片内部有两个端口，端口地址为70h和71h。CPU通过这两个端口读写CMOS RAM。
        5.70h为地址端口，存放要访问的CMOS RAM单元的地址；71h为数据端口，存放从选定的CMOS RAM单元中读取的数据
            或要写入到其中的数据
    2.比如：读CMOS RAM的2号单元：
        1.将2送入端口70h
        2.从71h读取2号单元的内容
14.3 shl和shr指令
    shl和shr是逻辑移位指令，后面的课程中我们要用到移位指令
    1.shl逻辑左移指令，功能为：
        1.将一个寄存器或内存单元中的数据向左移位
        2.将最后移出的移位写入cf中
        3.最低位用0补充
        例如有如下指令：
            mov al,01001000b
            shl al,1        ;将al中的数据左移一位
            执行后(al)=100100000b，cf=0.
        如果移动位数大于1时，必须将移动位数放在cl中
    2.shr逻辑右移指令，与shl刚好相反
14.4 CMOS RAM中存储的时间信息
    在CMOS RAM中存放着当前时间
      秒：00h
      分：02h
      时：04h
      日：07h
      月：08h
      年：09h
    这6个信息的长度都为1个字节
    这些数据以BCD码的方式存放，一个字节可以表示两个BCD码
    CMOS RAM存储时间信息的单元中存储了用两个BCD码表示的两个十进制数
        高4位的BCD码表示十位，低四位的BCD码表示个位
    【编程】：在屏幕中间显示当前的月份
        1.CMOS RAM芯片回顾：
            1.70h为地址端口，存放要访问的CMOS RAM单元的地址
            2.71h为数据端口，存放从选定的CMOS RAM单元中【读取】的数据，或【写入】其中的数据
        2.分析
          这个程序主要做两部分工作
            1.从CMOS RAM的8号单元读取当前月份的BCD码
                要读取CMOS RAM的信息，我们首先要向地址端口70h写入要访问的单元的地址
                mov al,8
                out 70h,al
                然后从数据端口71h中取得指定单元中的数据
                in al,71h
            2.将用BCD码表示的月份以十进制的形式显示到屏幕上
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">;编程：在屏幕中间显示当前的月份</span><br><span class="line">code segment</span><br><span class="line">    assume cs:code</span><br><span class="line">start:</span><br><span class="line">    mov	al,8</span><br><span class="line">    out 70h,al</span><br><span class="line">    in	al,71h</span><br><span class="line">    mov ah,al</span><br><span class="line">    mov cl,4</span><br><span class="line">    shr ah,cl</span><br><span class="line">    and al,00001111b</span><br><span class="line"></span><br><span class="line">    add ah,30h</span><br><span class="line">    add al,30h</span><br><span class="line"></span><br><span class="line">    mov bx,0b800h	;显存</span><br><span class="line">    mov es,bx</span><br><span class="line">    mov byte ptr es:[160*12+40*2],ah     ;显示月份的十位数码</span><br><span class="line">    mov byte ptr es:[160*12+40*2+2],al   ;显示月份的个位数码</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<pre><code>    【实验十四】编程：以“年/月/日 时:分:秒”的格式，显示当前日期和时间
</code></pre>
<h1 id="第十五章-外中断-1"><a href="#第十五章-外中断-1" class="headerlink" title="第十五章 外中断"></a>第十五章 外中断</h1><pre><code>**CPU除了有运算能力，还有I/O能力
15.1 接口芯片和端口
    1.在PC系统的接口卡和主板上，装有各种接口芯片，这些外设接口芯片的内部装有若干寄存器
        CPU将这些寄存器当做【端口】访问
    2.外设的输入不直接送入内存和CPU，而是送入相关的接口芯片的【端口】中
    3.CPU向外设的输出也是要先送入【端口】中，再由相关芯片送入到外设
    4.CPU可以向外设输出控制命令，这些控制命令也是先送到【端口】中，然后相关芯片根据命令进行相关工作
    5.可见：CPU与外部设备的交流是通过【端口】进行的
        CPU在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入  
15.2 外中断信息
    1.在PC系统中，外中断源一共有两类
        1.可屏蔽中断
        2.不可屏蔽中断
    2.可屏蔽中断是CPU可以不响应的外中断。CPU是否响应可屏蔽中断
        要看标志寄存器的IF位的设置
        当CPU检测到可屏蔽中断信息时：
        1.若IF=1，则CPU在执行完当前指令后相应中断，引发中断过程
        2.若IF=0，则不响应可屏蔽中断
    3.可屏蔽中断所引发的中断过程，除在第一步的实现上与内中断有所不同外，基本上和内中断的中断过程相同
    4.因为可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的
        而内中断的中断码是在CPU内部产生的
    5.IF设置为0的原因：在进入中断处理程序后，禁止其他的可屏蔽中断
        当然，如果中断处理程序中需要处理可屏蔽中断，可以用指令将IF设置为1
    6.8086CPU提供的设置IF的指令如下：
        sti         ;用于设置IF=1
        cli         ;用于设置IF=0
    7.不可屏蔽中断是CPU必须相应的外中断。
        当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后
        立即响应，应发中断过程
    8.8086CPU不可屏蔽中断的中断类型码固定为2，所以中断过程中，不需要取中断类型码
    9.不可屏蔽中断的中断过程
        1.标志寄存器入栈，IF=0，TF=0
        2.CS，IP入栈
        3.（IP）=（8），（CS）=（0AH）   ;固定地址
    10.几乎所有外中断，都是可屏蔽中断。当外设有需要处理的事件发生时
        相关芯片向CPU发出可屏蔽中断信息。
        不可屏蔽中断是系统中有必须处理的紧急情况发生时用来通知CPU的中断信息，本门课程中，主要讨论可屏蔽中断
15.3 PC机键盘的处理过程
    1.下面看一个键盘输入的处理过程，并以此来体会PC机处理外设输入的基本方法
        1.键盘输入
        2.引发9号中断
        3.执行int 9中断例程
    2.PC机键盘的处理过程
        1.键盘上每一个键相当于一个开关，键盘中有一个芯片对键盘上的每一触键的开关状态进行扫描。
        2.按下一个键时，开关接通，该芯片就产生一个扫描码，扫描码说明按下的键在键盘上的位置
            扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为60H
        3.松开控下的键时，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置，松开按键时
            产生的扫描码也被送入60H端口中。
          一般按下一个键时，产生的扫描码称为通码，松开一个键产生的扫描码称为断码
          扫描码长度为一个字节，通码的第七位为0，断码的第七位为1
            即：断码=通码+80H
          **BIOS提供了int9中断例程，用来进行基本的键盘输入处理，主要的工作如下：
            1.读出60H端口中的扫描码
            2.如果是字符键的扫描码，将该扫描码对应的字符码（即：ASCII码）送入内存中的BIOS键盘缓冲区
            3，如果是控制键和切换键的扫描码，则将其转变为状态字节，写入内存中存储状态字节的单元
        4.键盘的输入到达60H端口时，相关的芯片会向CPU发出中断类型码为9的可屏蔽中断信息。
        5.CPU检测到中断信息后，如果IF=1，则相应中断，同时将IF设置为0（不让其他可屏蔽中断进行干扰），引发中断过程，转去执行int9中断例程
    3.BIOS键盘缓冲区是系统启动后，BIOS用于存放int9中断例程所接受的键盘输入的内存区
    4.该内存区可以存储15个键盘输入，int9中断例程除了接收扫描码外，还要产生和扫描码对应的字符码，
        所以在BIOS键盘缓冲区中，一个键盘输入用一个字单元存放，高字节存放扫描码，低字节存放字符码
    5.0040:17单元存储键盘状态字节，该字节记录了控制键和切换键的状态。键盘状态字节各位记录的信息如下：
</code></pre>
<p><img src="/img_ass/15.1.png" class="lazyload" data-srcset="/img_ass/15.1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="avatar"></p>
<pre><code>15.4 编写int9中断例程,并安装
    梳理键盘输入的处理过程
        1.键盘产生扫描码
        2.扫描码送入60H端口
        3.一旦侦测到60H端口有动静，引发9号中断
        4.CPU执行int9中断例程处理输入
      以上的过程，前三步都由硬件系统自动完成，能够修改的只有第四步，修改int9中断程序
    【任务演示】在屏幕中依次显示“a”~“z”并可以让人看清。在显示过程中，按下Esc键后，该表显示的颜色
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">;程序1：实现连续显示“a”~“z”</span><br><span class="line">;编程：在屏幕中间依次显示“a”~“z”，并可以让人看清。在显示的过程中，按下&#x27;Esc&#x27;键后，改变显示的颜色。</span><br><span class="line">;部分功能代码：</span><br><span class="line">stack segment</span><br><span class="line">	db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    assume cs:code</span><br><span class="line">start:  </span><br><span class="line">	mov ax,stack</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov sp,128</span><br><span class="line"></span><br><span class="line">	mov ax,0b800h</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ah,&#x27;a&#x27;</span><br><span class="line">s:	mov es:[160*12+40*2],ah</span><br><span class="line">	call delay</span><br><span class="line">	inc ah</span><br><span class="line">	cmp ah,&#x27;z&#x27;</span><br><span class="line">	jna s</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line">delay:	</span><br><span class="line">	push ax</span><br><span class="line">	push dx</span><br><span class="line">	mov dx,0010h	;循环10000000h次</span><br><span class="line">	mov ax,0</span><br><span class="line">s1:	                   </span><br><span class="line">	sub ax,1</span><br><span class="line">	sbb dx,0</span><br><span class="line">	cmp ax,0</span><br><span class="line">	jne s1</span><br><span class="line">	cmp dx,0</span><br><span class="line">	jne s1</span><br><span class="line">	pop dx</span><br><span class="line">	pop ax</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start </span><br><span class="line"></span><br><span class="line">;程序2：实现改变颜色</span><br><span class="line">;编程：在屏幕中间依次显示“a”~“z”，并可以让人看清。在显示的过程中，按下&#x27;Esc&#x27;键后，改变显示的颜色。</span><br><span class="line">stack segment</span><br><span class="line">	db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	dw 0,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    assume cs:code</span><br><span class="line">start:	</span><br><span class="line">	mov ax,stack</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov sp,128</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov ax,0</span><br><span class="line">	mov es,ax</span><br><span class="line"></span><br><span class="line">	push es:[9*4]</span><br><span class="line">	pop ds:[0]</span><br><span class="line">	push es:[9*4+2]</span><br><span class="line">	pop ds:[2]			;将原来的int 9中断例程的入口地址保存在ds:0、ds:2单元中</span><br><span class="line"></span><br><span class="line">	mov word ptr es:[9*4],offset int9</span><br><span class="line">	mov es:[9*4+2],cs	;在中断向量表中设置新的int 9中断例程的入口地址</span><br><span class="line"></span><br><span class="line">	mov ax,0b800h</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov ah,&#x27;a&#x27;</span><br><span class="line">s:	</span><br><span class="line">	mov  es:[160*12+40*2],ah</span><br><span class="line">	call delay</span><br><span class="line">	inc ah</span><br><span class="line">	cmp ah,&#x27;z&#x27;</span><br><span class="line">	jna s</span><br><span class="line">	mov ax,0</span><br><span class="line">	mov es,ax</span><br><span class="line"></span><br><span class="line">	push ds:[0]</span><br><span class="line">	pop es:[9*4]</span><br><span class="line">	push ds;[2]</span><br><span class="line">	pop es;[9*4+2]   	;将中断向量表中int 9中断例程的入口恢复为原来的地址</span><br><span class="line"></span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line"></span><br><span class="line">delay:	</span><br><span class="line">	push ax</span><br><span class="line">	push dx</span><br><span class="line">	mov dx,0010h</span><br><span class="line">	mov ax,0</span><br><span class="line">s1: 	</span><br><span class="line">	sub ax,1</span><br><span class="line">	sbb dx,0</span><br><span class="line">	cmp ax,0</span><br><span class="line">	jne s1</span><br><span class="line">	cmp dx,0</span><br><span class="line">	jne s1</span><br><span class="line">	pop dx</span><br><span class="line">	pop ax</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">;------以下为新的int 9中断例程--------------------</span><br><span class="line">;int9中断例程是在进行键盘输入之后，由系统自动调用</span><br><span class="line">int9:	</span><br><span class="line">	push ax</span><br><span class="line">	push bx</span><br><span class="line">	push es</span><br><span class="line"></span><br><span class="line">	in al,60h</span><br><span class="line"></span><br><span class="line">	pushf</span><br><span class="line">	pushf</span><br><span class="line">	pop bx</span><br><span class="line">	and bh,11111100b</span><br><span class="line">	push bx</span><br><span class="line">	popf</span><br><span class="line">	call dword ptr ds:[0] 				;对int指令进行模拟，调用原来的int 9中断例程</span><br><span class="line"></span><br><span class="line">	cmp al,1</span><br><span class="line">	jne int9ret</span><br><span class="line"></span><br><span class="line">	mov ax,0b800h</span><br><span class="line">	mov es,ax</span><br><span class="line">	inc byte ptr es:[160*12+40*2+1]  	;属性增加1，改变颜色</span><br><span class="line"></span><br><span class="line">int9ret:</span><br><span class="line">	pop es</span><br><span class="line">	pop bx</span><br><span class="line">	pop ax</span><br><span class="line">	iret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h1 id="第十六章-直接定址表-1"><a href="#第十六章-直接定址表-1" class="headerlink" title="第十六章 直接定址表"></a>第十六章 直接定址表</h1><pre><code>16.1 描述了单元长度的标号
    1.本章讨论如何有效合理地组织数据，以及相关的编程技术
        1.前面的课程中，我们一直在代码段中使用标号来标记指令、数据、段的起始地址
        2.还可以使用一种标号，这种标号不但可以表示内存单元的地址，还表示了内存单元的长度
            即：表示在此标号处的单元，是一个字节单元，还是字单元还是双字单元
    2.例如
        1.标号1
        a : db 1,2,3,4,5,6,7,8
        b : dw 0
      此种标号只能标记地址
      此种加有“:”的地址标号，只能在代码段中使用，不能在其他段中使用
        2.标号2
        a db 1,2,3,4,5,6,7,8    ;标号a，描述了地址code:0,和从这个地址开始，以后的内存单元都是字节单元
        b dw 0                  ;标号b描述了地址code:8，和从这个地址开始，以后的内存单元都是字单元
      此种标号既可以标记地址，也可以表示此标号处的单元
    3.使用这种包含单元长度的标号，可以使我们以简洁的形式访问内存中的数据
      这种标号此后称为数据标号，它标记了存储数据的单元的地址和长度
    4.数据标号的用法
        指令：mov ax,b             ;相当于：mov ax,cs:[8]
        指令：mov b,2              ;相当于：mov word ptr cs:[8],2
        指令：inc b                ;相当于：inc word ptr cs:[8]
        指令：mov al,a [si]        ;相当于：mov al,cs:0[si]
        指令：mov al,a[3]          ;相当于：mov al,cs:0[3]
        指令：mov al,a[bx+si+3]    ;相当于：mov al,cs:0[bx+si+3]
16.2 在其他段中使用数据标号
    1.注意，如果想在代码段中，直接用数据标号访问数据，
        则需要用伪指令assume 将标号所在的段和一个段寄存器联系起来。
      否则编译器在编译的时候，无法确定标号的段地址在哪一个寄存器中。
    2. 当然，这种联系是编译器需要的，但绝对不是说，我们因为编译器的工作需要，
        用assume指令将段寄存器和某个段相联系，段寄存器中就会真的存放该段的地址。
    3.我们可以将数据标号当作数据来定义，此时，编译器将标号所表示的地址当作数据的值。 
      1.把数据标号当做数据来定义时，使用【dw】定义数据
      比如：     data segment
                      a db 1,2,3,4,5,6,7,8
                    	b dw 0
                    c dw a,b        ;数据标号c处存储的两个字型数据为标号a、b 的偏移地址。
                   data ends
      数据标号c处存储的两个字型数据为标号a、b 的偏移地址。
      相当于：
                data segment
                    a db 1,2,3,4,5,6,7,8
                    b dw 0
                    c dw offset a, offset b
                 data ends
      2.把数据标号当做数据来定义时，使用【dd】定义数据
        再比如：
            data segment
                a db 1,2,3,4,5,6,7,8
                b dw 0
                c dd a,b    ;数据标号c处存储的两个双字型数据为标号a的偏移地址和段地址、标号b 的偏移地址和段地址。
             data ends
        数据标号c处存储的两个双字型数据为标号a的偏移地址和段地址、标号b 的偏移地址和段地址。
        相当于：
            data segment
                    a db 1,2,3,4,5,6,7,8
                    b dw 0
                    c dw offset a, seg a, offset b, seg b   ;seg操作符，功能为取得某一标号的段地址。
                 data ends
            seg操作符，功能为取得某一标号的段地址。
16.3 直接定址表
    本节课，我们将使用“查表”的方法，编写相关程序的技巧
    【任务】编写子程序，以十六进制的形式在屏幕中间显示给定的byte型数据
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">code segment</span><br><span class="line">    assume cs:code</span><br><span class="line">start:  </span><br><span class="line">		mov al,0eh          ;al中存放了byte型数据</span><br><span class="line"></span><br><span class="line">        call showbyte</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">;子程序：</span><br><span class="line">;用al传送要显示的数据</span><br><span class="line"></span><br><span class="line">showbyte:</span><br><span class="line">        jmp short show</span><br><span class="line"></span><br><span class="line">        table db &#x27;0123456789ABCDEF&#x27;	;字符表</span><br><span class="line"></span><br><span class="line">show:   push bx                 ;保护现场</span><br><span class="line">        push es</span><br><span class="line"></span><br><span class="line">        mov ah,al</span><br><span class="line">        shr ah,1           </span><br><span class="line">        shr ah,1</span><br><span class="line">        shr ah,1</span><br><span class="line">        shr ah,1			    ;右移4位，ah中得到高4位的值</span><br><span class="line">        and al,00001111b		;al中为低4位的值</span><br><span class="line"></span><br><span class="line">        mov bl,ah</span><br><span class="line">        mov bh,0</span><br><span class="line">        mov ah,table[bx]		;用高4位的值作为相对于table的偏移，取得对应的字符</span><br><span class="line"></span><br><span class="line">        mov bx,0b800h</span><br><span class="line">        mov es,bx</span><br><span class="line">        mov es:[160*12+40*2],ah</span><br><span class="line"></span><br><span class="line">        mov bl,al</span><br><span class="line">        mov bh,0</span><br><span class="line">        mov al,table[bx]		;用低4位的值作为相对于table的偏移，取得对应的字符</span><br><span class="line">        </span><br><span class="line">        mov es:[160*12+40*2+2],al</span><br><span class="line"></span><br><span class="line">        pop es</span><br><span class="line">        pop bx</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<pre><code>16.4 程序入口地址的直接定址表
    【编程】实现一个子程序setscreen，为显示输出提供如下功能：
        1.清屏
        2.设置前景色
        3.设置背景色
        4.向上滚动一行
    1.入口参数说明：
        1.用ah寄存器传递功能号
            0：清屏；1：设置前景色；2：设置背景色；3：向上滚动一行
        2.对于2、3号功能，用al传递颜色值
            al∈&#123;0，1，2，3，4，5，6，7&#125;
    2.各种功能如何实现
        1.清屏：
            将显存中当前屏幕中的字符设为空格符；
        2.设置前景色：
            设置显存中当前屏幕中处于奇地址的属性字节的第0、1、2位；
            012位存放前景色
        3.设置背景色：
            设置显存中当前屏幕中处于奇地址的属性字节的第4、5、6位；
            456位存放背景色
        4.向上滚动一行：
            依次将第 n+1行的内容复制到第n行处：最后一行为空。  
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">;功能子程序1：清屏</span><br><span class="line">sub1:      push bx      ;保护现场,调用子程序的时候，注意要保护现场，运行子程序的时候，可能会修改一些寄存器的值</span><br><span class="line">        push cx</span><br><span class="line">        push es</span><br><span class="line">        mov bx,0b800h</span><br><span class="line">        mov es,bx</span><br><span class="line">        mov bx,0</span><br><span class="line">        mov cx,2000</span><br><span class="line">sub1s:    mov byte ptr es:[bx],&#x27; &#x27;  ;循坏2000次</span><br><span class="line">        add bx,2</span><br><span class="line">        loop sub1s</span><br><span class="line">        pop es          ;恢复现场</span><br><span class="line">        pop cx</span><br><span class="line">        pop bx</span><br><span class="line">        ret 	</span><br><span class="line">;功能子程序2：设置前景</span><br><span class="line">sub2:	push bx</span><br><span class="line">	push cx</span><br><span class="line">	push es</span><br><span class="line">	mov bx,0b800h</span><br><span class="line">	mov es,bx</span><br><span class="line">	mov bx,1</span><br><span class="line">	mov cx,2000</span><br><span class="line">sub2s:	and byte ptr es:[bx],11111000b	</span><br><span class="line">	or es:[bx],al </span><br><span class="line">	add bx,2</span><br><span class="line">	loop sub2s</span><br><span class="line"></span><br><span class="line">	pop es</span><br><span class="line">	pop cx</span><br><span class="line">	pop bx</span><br><span class="line">	ret		</span><br><span class="line">;功能子程序3：设置背景色</span><br><span class="line">sub3:	push bx</span><br><span class="line">	push cx</span><br><span class="line">	push es</span><br><span class="line">	mov cl,4</span><br><span class="line">	shl al,cl</span><br><span class="line">	mov bx,0b800h</span><br><span class="line">	mov es,bx</span><br><span class="line">	mov bx,1</span><br><span class="line">	mov cx,2000</span><br><span class="line">sub3s:	and byte ptr es:[bx],10001111b</span><br><span class="line">	or es:[bx],al </span><br><span class="line">	add bx,2</span><br><span class="line">	loop sub2s</span><br><span class="line"></span><br><span class="line">	pop es</span><br><span class="line">	pop cx</span><br><span class="line">	pop bx</span><br><span class="line">	ret </span><br><span class="line">;功能子程序4：向上滚动一行</span><br><span class="line">sub4:	</span><br><span class="line">	push cx</span><br><span class="line">	push si</span><br><span class="line">	push di</span><br><span class="line">	push es</span><br><span class="line">	push ds</span><br><span class="line"></span><br><span class="line">	mov si,0b800h</span><br><span class="line">	mov es,si</span><br><span class="line">	mov ds,si</span><br><span class="line">	mov si,160			;ds:si指向第n+1行，第1行</span><br><span class="line">	mov di,0			;es:di指向第n行，第0行</span><br><span class="line">	cld</span><br><span class="line">	mov cx,24;共复制24行</span><br><span class="line"></span><br><span class="line">sub4s:	</span><br><span class="line">	push cx</span><br><span class="line">	mov cx,160</span><br><span class="line">	rep movsb 			;复制</span><br><span class="line">  	pop cx</span><br><span class="line">	loop sub4s</span><br><span class="line"></span><br><span class="line">	mov cx,80	</span><br><span class="line">	mov si,0</span><br><span class="line">	</span><br><span class="line">sub4s1: </span><br><span class="line">	mov byte ptr es:[160*24+si],&#x27; &#x27;		;最后一行清空</span><br><span class="line">	add si,2</span><br><span class="line">	loop sub4s1</span><br><span class="line"></span><br><span class="line">	pop ds</span><br><span class="line">	pop es</span><br><span class="line">	pop di</span><br><span class="line">	pop si</span><br><span class="line">	pop cx</span><br><span class="line">	ret ;sub4 ends</span><br></pre></td></tr></table></figure>
<pre><code>    3.可以将这些功能子程序的入口地址存储在一个表中，他们在表中的位置和功能号相对应
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">;编程：实现一个子程序setscreen，为显示输出提供如下功能：</span><br><span class="line">;(1) 清屏。</span><br><span class="line">;(2) 设置前景色。</span><br><span class="line">;(3) 设置背景色。</span><br><span class="line">;(4) 向上滚动一行。</span><br><span class="line">;</span><br><span class="line">;入口参数说明：</span><br><span class="line">;(1) 用 ah 寄存器传递功能号：0 表示清屏，1表示设置前景色，2 表示设置背景色，3 表示向上滚动一行；</span><br><span class="line">;(2) 对于2、3号功能，用 al 传送颜色值，(al) ∈&#123;0,1,2,3,4,5,6,7&#125;</span><br><span class="line"></span><br><span class="line">setscreen: jmp short set</span><br><span class="line"></span><br><span class="line">    table  dw sub1,sub2,sub3,sub4</span><br><span class="line"></span><br><span class="line">set:	</span><br><span class="line">	push bx	</span><br><span class="line">	cmp ah,3		;判断传递的是否大于 3</span><br><span class="line">	ja sret</span><br><span class="line">	mov bl,ah</span><br><span class="line">	mov bh,0</span><br><span class="line">	add bx,bx		;根据ah中的功能号计算对应子程序的地址在table表中的偏移</span><br><span class="line">	</span><br><span class="line">	call word ptr table[bx]	;调用对应的功能子程序，学会本句代码，是本章节的【精髓】</span><br><span class="line"></span><br><span class="line">sret:	</span><br><span class="line">	pop bx	</span><br><span class="line">	iret</span><br><span class="line"></span><br><span class="line">;功能子程序1：清屏</span><br><span class="line">sub1:   </span><br><span class="line">	push bx</span><br><span class="line">	push cx</span><br><span class="line">    push es</span><br><span class="line">	mov bx,0b800h</span><br><span class="line">	mov es,bx</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov cx,2000</span><br><span class="line">	</span><br><span class="line">sub1s:  </span><br><span class="line">	mov byte ptr es:[bx],&#x27; &#x27;</span><br><span class="line">    add bx,2</span><br><span class="line">    loop sub1s</span><br><span class="line">    pop es</span><br><span class="line">    pop cx</span><br><span class="line">    pop bx</span><br><span class="line">	ret ;sub1 ends</span><br><span class="line"></span><br><span class="line">;功能子程序2：设置前景色</span><br><span class="line">sub2:	</span><br><span class="line">	push bx</span><br><span class="line">	push cx</span><br><span class="line">	push es</span><br><span class="line">	mov bx,0b800h</span><br><span class="line">	mov es,bx</span><br><span class="line">	mov bx,1</span><br><span class="line">	mov cx,2000</span><br><span class="line">	</span><br><span class="line">sub2s:	</span><br><span class="line">	and byte ptr es:[bx],11111000b	</span><br><span class="line">	or es:[bx],al </span><br><span class="line">	add bx,2</span><br><span class="line">	loop sub2s</span><br><span class="line"></span><br><span class="line">	pop es</span><br><span class="line">	pop cx</span><br><span class="line">	pop bx</span><br><span class="line">	ret ;sub2 ends</span><br><span class="line"></span><br><span class="line">;功能子程序3：设置背景色</span><br><span class="line">sub3:	</span><br><span class="line">	push bx</span><br><span class="line">	push cx</span><br><span class="line">	push es</span><br><span class="line">	mov cl,4</span><br><span class="line">	shl al,cl</span><br><span class="line">	mov bx,0b800h</span><br><span class="line">	mov es,bx</span><br><span class="line">	mov bx,1</span><br><span class="line">	mov cx,2000</span><br><span class="line">	</span><br><span class="line">sub3s:	</span><br><span class="line">	and byte ptr es:[bx],10001111b</span><br><span class="line">	or es:[bx],al </span><br><span class="line">	add bx,2</span><br><span class="line">	loop sub2s</span><br><span class="line"></span><br><span class="line">	pop es</span><br><span class="line">	pop cx</span><br><span class="line">	pop bx</span><br><span class="line">	ret ; sub3 ends</span><br><span class="line"></span><br><span class="line">;功能子程序4：向上滚动一行</span><br><span class="line">sub4:	</span><br><span class="line">	push cx</span><br><span class="line">	push si</span><br><span class="line">	push di</span><br><span class="line">	push es</span><br><span class="line">	push ds</span><br><span class="line"></span><br><span class="line">	mov si,0b800h</span><br><span class="line">	mov es,si</span><br><span class="line">	mov ds,si</span><br><span class="line">	mov si,160			;ds:si指向第n+1行</span><br><span class="line">	mov di,0			;es:di指向第n行</span><br><span class="line">	cld</span><br><span class="line">	mov cx,24;共复制24行</span><br><span class="line"></span><br><span class="line">sub4s:	</span><br><span class="line">	push cx</span><br><span class="line">	mov cx,160</span><br><span class="line">	rep movsb 			;复制</span><br><span class="line">  	pop cx</span><br><span class="line">	loop sub4s</span><br><span class="line"></span><br><span class="line">	mov cx,80	</span><br><span class="line">	mov si,0</span><br><span class="line">	</span><br><span class="line">sub4s1: </span><br><span class="line">	mov byte ptr es:[160*24+si],&#x27; &#x27;		;最后一行清空</span><br><span class="line">	add si,2</span><br><span class="line">	loop sub4s1</span><br><span class="line"></span><br><span class="line">	pop ds</span><br><span class="line">	pop es</span><br><span class="line">	pop di</span><br><span class="line">	pop si</span><br><span class="line">	pop cx</span><br><span class="line">	ret ;sub4 ends</span><br></pre></td></tr></table></figure>
<h1 id="第十七章-使用BIOS进入键盘输入和磁盘读写-1"><a href="#第十七章-使用BIOS进入键盘输入和磁盘读写-1" class="headerlink" title="第十七章 使用BIOS进入键盘输入和磁盘读写"></a>第十七章 使用BIOS进入键盘输入和磁盘读写</h1><pre><code>**引言
    1.大多数有用的程序都需要处理用户的输入，键盘输入是最基本的输入。
    2.程序和数据通常需要长期存储，磁盘是最常用的存储设备。
    3.BIOS 为这两种外设的I/O提供了最基本的中断例程，在本章中，我们对它们的应用和相关的问题进行讨论。
17.1 int9中断例程对键盘输入的处理
    CPU 在9 号中断发生后，执行int 9中断例程，从60h 端口读出扫描码，
        并将其转化为相应的ASCII 码或状态信息，存储在内存的指定空间（键盘缓冲区或状态字节）中。
17.2 使用int16h中断例程读取键盘缓冲区
    1.BIOS提供了int 16h 中断例程供程序员调用。
    2.int 16h 中断例程中包含的一个最重要的功能是从键盘缓冲区中读取一个键盘输入，该功能的编号为0。
    3.下面的指令从键盘缓冲区（缓冲区的最低位）中读取一个键盘输入，并且将其从缓冲区中删除：
           mov ah,0
           int 16h
      结果：(ah)=扫描码，(al)=ASCII码。
    4.int 16h 中断例程的 0 号功能，进行如下的工作：
        （1）检测键盘缓冲区中是否有数据；
        （2）没有则继续做第1 步；（缓冲区随时有可能输入数据）
        （3）读取缓冲区第一个字单元中的键盘输入；
        （4）将读取的扫描码送入ah，ASCII 码送入al；
        （5）将己读取的键盘输入从缓冲区中删除。
    5.可见，B1OS 的int 9 中断例程和int 16h 中断例程是一对相互配合的程序，
        int 9 中断例程向键盘缓冲区中写入，
        int 16h 中断例程从缓冲区中读出。
      它们写入和读出的时机不同，int 9 中断例程在有键按下的时候向键盘缓冲区中写入数据；
      而int 16h 中断例程是在应用程序对其进行调用的时候，将数据从键盘缓冲区中读出。
    【编程】接收用户的键盘输入，输入“r”，将屏幕上的字符设置为红色：输入“g”， 
        将屏幕上的字符设置为绿色；输入“b ”，将屏幕上的字符设置为蓝色。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">;编程：</span><br><span class="line">;接收用户的键盘输入，输入“r”，将屏幕上的字符设置为红色：输入“g”， </span><br><span class="line">;将屏幕上的字符设置为绿色；输入“b ”，将屏幕上的字符设置为蓝色。</span><br><span class="line">;A、B、C处的程序指令比较有技巧，请读者自行分析</span><br><span class="line">code segment</span><br><span class="line">    assume cs:code</span><br><span class="line">start:	</span><br><span class="line">	mov ah,0</span><br><span class="line">	int 16h				;int 16h 0号功能实现从键盘缓冲区读取一个键盘输入</span><br><span class="line">		</span><br><span class="line">	mov ah,1			;A</span><br><span class="line">	cmp al,&#x27;r&#x27;</span><br><span class="line">	je red</span><br><span class="line">	cmp al,&#x27;g&#x27;</span><br><span class="line">	je green</span><br><span class="line">	cmp al,&#x27;b&#x27;</span><br><span class="line">	je blue</span><br><span class="line">	jmp short sret</span><br><span class="line">	</span><br><span class="line">red:	</span><br><span class="line">	shl ah,1			;B</span><br><span class="line">green:	</span><br><span class="line">	shl ah,1			;C</span><br><span class="line"></span><br><span class="line">blue:	</span><br><span class="line">	mov bx,0b800h</span><br><span class="line">	mov es,bx</span><br><span class="line">	mov bx,1</span><br><span class="line">	mov cx,2000</span><br><span class="line">s:	and byte ptr es:[bx],11111000b      ;设置颜色</span><br><span class="line">	or es:[bx],ah                       ;设置颜色</span><br><span class="line">	add bx,2</span><br><span class="line">	loop s</span><br><span class="line"></span><br><span class="line">sret:	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">	</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<pre><code>17.3 字符串的输入
    int 21h的0a号功能可以实现字符串的输入
    也可以用int 16h，通过显示键盘缓冲区中的内容，实现字符串的显示
    1.使用int 16h显示字符串程序的处理过程如下
        ① 调用int 16h读取键盘输入；
        ② 如果是字符，进入字符栈，显示字符栈中的所有字符；继续执行① ；
        ③ 如果是退格键，从字符栈中弹出一个字符，显示字符栈中的所有字符；继续执行① ；
        ④ 如果是Enter 键，向字符栈中压入0，返回。
    2.子程序：字符栈的入栈、出栈和显示
        参数说明
        (ah)=功能号，0表示入栈，1表示出栈，2表示显示；
            ds : si 指向字符栈空间；
        对于0 号功能：(al)=入栈字符；
        对于1 号功能：(al)=返回的字符；
        对于2 号功能：(dh)、(dl) =字符串在屏幕上显示的行、列位置。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">;使用int 16h显示字符串的子程序：字符栈</span><br><span class="line">;最基本的字符串输入程序，需要具备下面的功能：</span><br><span class="line">;（1） 在输入的同时需要显示这个字符串；</span><br><span class="line">;（2）一般在输入回车符后，字符串输入结束；</span><br><span class="line">;（3）能够删除已经输入的字符。</span><br><span class="line"></span><br><span class="line">;编写一个接收字符串的输入子程序，实现上面三个基本功能。</span><br><span class="line">;因为在输入的过程中需要显示，子程序的参数如下：</span><br><span class="line">;	(dh)、(dl)=字符串在屏幕上显示的行、列位置；</span><br><span class="line">;	ds:si 指向字符串的存储空间，字符串以O 为结尾符。</span><br><span class="line"></span><br><span class="line">;功能子程序实现</span><br><span class="line"></span><br><span class="line">charstack:</span><br><span class="line">	jmp short charstart</span><br><span class="line">	</span><br><span class="line">	table dw charpush,charpop,charshow</span><br><span class="line">	top dw 0   							;栈顶</span><br><span class="line">   </span><br><span class="line">charstart:</span><br><span class="line">	push bx</span><br><span class="line">	push dx</span><br><span class="line">	push di</span><br><span class="line">	push es</span><br><span class="line"></span><br><span class="line">	cmp ah,2</span><br><span class="line">	ja sret</span><br><span class="line">	mov bl,ah</span><br><span class="line">	mov bh,0</span><br><span class="line">	add bx,bx</span><br><span class="line">	jmp word ptr table[bx]      ;使用直接定址表</span><br><span class="line"></span><br><span class="line">charpush:</span><br><span class="line">	mov bx,top</span><br><span class="line">	mov [si][bx],al</span><br><span class="line">	inc top</span><br><span class="line">	jmp sret</span><br><span class="line"></span><br><span class="line">charpop:</span><br><span class="line">	cmp top,0</span><br><span class="line">	je sret</span><br><span class="line">	dec top</span><br><span class="line">	mov bx,top</span><br><span class="line">	mov al,[si][bx]	</span><br><span class="line">	jmp sret</span><br><span class="line"></span><br><span class="line">charshow:</span><br><span class="line">	mov bx,0b800h</span><br><span class="line">	mov es,bx</span><br><span class="line">	mov al,160</span><br><span class="line">	mov ah,0	</span><br><span class="line">	mul dh</span><br><span class="line">	mov di,ax</span><br><span class="line">	add dl,dl</span><br><span class="line">	mov dh,0</span><br><span class="line">	add di,dx</span><br><span class="line"></span><br><span class="line">	mov bx,0</span><br><span class="line"></span><br><span class="line">charshows:</span><br><span class="line">	cmp bx,top</span><br><span class="line">	jne noempty</span><br><span class="line">	mov byte ptr es:[di],&#x27; &#x27;	</span><br><span class="line">	jmp sret</span><br><span class="line"></span><br><span class="line">noempty:</span><br><span class="line">	mov al,[si][bx]</span><br><span class="line">	mov es:[di],al</span><br><span class="line">	mov byte ptr es:[di+2],&#x27; &#x27;</span><br><span class="line">	inc bx</span><br><span class="line">	add di,2</span><br><span class="line">	jmp charshows</span><br><span class="line"></span><br><span class="line">sret:	</span><br><span class="line">	pop es</span><br><span class="line">	pop di</span><br><span class="line">	pop dx</span><br><span class="line">	pop bx</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<pre><code>17.4 应用int13h中断例程对键盘进行读写
    1.磁盘的实际访问由磁盘控制器进行，我们可以通过控制磁盘控制器来访问磁盘。
    2.注意，我们只能以扇区为单位对磁盘进行读写。
      在读写扇区的时候，要给出面号、磁道号和扇区号。面号和磁道号从0开始，而扇区号从1开始。
    3.BIOS提供了对扇区进行读写的中断例程，这些中断例程完成了许多复杂的和硬件相关的工作。
    4.我们可以通过调用BIOS中断例程来访问磁盘。
        BIOS 提供的访问磁盘的中断例程为int 13h 。
      如下，读取0面0道1扇区的内容到0:200： 
</code></pre>
<p><img src="/img_ass/17.1.png" class="lazyload" data-srcset="/img_ass/17.1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="avatar"></p>
<pre><code>        返回参数：
            操作成功：（ah）=0，（al）=读入的扇区数
            操作失败：（ah）=出错代码
      将0:200中的内容写入0面0道1扇区示例
        返回参数：
</code></pre>
<p><img src="/img_ass/17.2.png" class="lazyload" data-srcset="/img_ass/17.2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="avatar"></p>
<pre><code>            操作成功： (ah)=0，(al)=写入的扇区数
            操作失败： (ah)=出错代码
    5.注意：使用int 13h 中断例程对软盘进行读写。直接向磁盘扇区写入数据是很危险的，
       很可能覆盖掉重要的数据。
    【编程】将当前屏幕的内容保存在磁盘上
        分析：1 屏的内容占4000个字节，需要8 个扇区（一个扇区512B），我们用0面0道的1~8扇区存储显存中的内容。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">code segment</span><br><span class="line">    assume cs:code</span><br><span class="line">start:	</span><br><span class="line">	mov ax,0b800h</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov bx,0	;es:bx	指向将写入磁盘的数据的内存区</span><br><span class="line"></span><br><span class="line">	mov al,8 	;写入的扇区数</span><br><span class="line">	mov ch,0 	;磁道号，从0开始</span><br><span class="line">	mov cl,1 	;扇区号 从1开始</span><br><span class="line">	mov dl,0 	;驱动器号0:软驱A,  1:软驱B,硬盘从80h开始， 80h:硬盘C，81h:硬盘D</span><br><span class="line">	mov dh,0 	;磁头号，（对于软盘即面号，因为一个面用一个磁头来读写）</span><br><span class="line">	mov ah,3	;传递 int 13h 写入数据的功能号</span><br><span class="line">	int 13h</span><br><span class="line"></span><br><span class="line">			;返回参数</span><br><span class="line">			;操作成功:(ah) = 0,(al) = 写入的扇区数</span><br><span class="line">			;操作失败:(ah) = 出错代码</span><br><span class="line">	</span><br><span class="line">return:	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<pre><code>    【实验17和课程设计2】
        课程设计1在第十章
</code></pre>
<h1 id="综合研究"><a href="#综合研究" class="headerlink" title="综合研究"></a>综合研究</h1><pre><code>研究试验1 搭建一个精简的C语言开发环境
研究试验2 使用寄存器
研究试验3 使用内存空间
研究试验4 不用main函数编程
研究试验5 函数如何接受不定数量的参数
</code></pre>

  </div>
  
  
    
    <div class='footer'>
       <!-- 参考资料、相关资料等 -->
      
       <!-- 相关文章 -->
      
      <!-- 版权声明组件 -->
      
      <!-- 打赏组件 -->
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateModified" datetime="2023-08-04T23:03:02+08:00">
  <a class='notlink'>
    <i class="fa-solid fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：Aug 4, 2023</p>
  </a>
</div>

        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://example.com/2023/08/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/&title= - Hexo&summary="
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qq.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qq.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://example.com/2023/08/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/&title= - Hexo&summary="
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qzone.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qzone.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://service.weibo.com/share/share.php?url=http://example.com/2023/08/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/&title= - Hexo&summary="
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/weibo.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/weibo.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
    
      
    
  </div>
</div>



        
      
    </div>
    <!-- Custom Files bottomMeta begin -->
    
    <!-- Custom Files bottomMeta end -->
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/2023/10/21/%E5%BA%9F%E6%9D%90%E8%80%81%E5%93%A5/'>
          <p class='title'><i class="fa-solid fa-chevron-left" aria-hidden="true"></i>Aug 4, 2023</p>
          <p class='content'>headings (废材老哥-视频下评论)小时候觉得忘带作业是天大的事，初中的时候，觉得考不上大学是天大的事，恋爱的时候，觉得跟喜欢的人分开是天大的事，到现在回头看看，那些难以跨过的山，其实都在...</p>
        </a>
      
      
        <a class='next' href='/2023/04/29/%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%B7%AF/'>
          <p class='title'>笔记之路<i class="fa-solid fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'>笔记之路学生时代，我们是如何学习的？

课本
优点：知识全面详细
缺点：
知识调理不清晰
重难点不突出





板书
优点：

知识调理清晰
重难点突出+扩展


缺点：面向全体学生


笔记...</p>
        </a>
      
    </div>
  
  <!-- Custom Files postEnd begin-->
  
  <!-- Custom Files postEnd end-->
</article>


  


  <article class="post white-box shadow floatable blur" id="comments">
    <span hidden>
      <meta itemprop="discussionUrl" content="/2023/08/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html#comments">
    </span>
    <p ct><i class='fa-solid fa-comments'></i> 评论</p>
    

    <div id="layoutHelper-comments"></div>

  </article>






</div>
<aside id='l_side' itemscope itemtype="http://schema.org/WPSideBar">
  

  
    
    
      
    
  


<div class="widget-sticky pjax">

  
  


  <section class="widget toc-wrapper desktop mobile " id="toc-div" >
    
  <header>
    
      <i class="fa-solid fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-text">目录</span></a></li></ol>
    </div>
  </section>

  

</div>


<!-- 没有 pjax 占位会报错 万恶的 pjax -->

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <!-- Custom Files side begin -->
  
  <!-- Custom Files side end -->
</aside>



          <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->

<pjax>
<script>
  window.pdata={}
  pdata.ispage=false;
  pdata.commentPath="";
  pdata.commentPlaceholder="";
  pdata.commentConfig={};
  //  see: /layout/_partial/scripts/_ctrl/coverCtrl.ejs
  
    // header
    var l_header=document.getElementById("l_header");
    
    l_header.classList.add("show");
    
    
      // cover
      var cover_wrapper=document.querySelector('#l_cover .cover-wrapper');
      var scroll_down=document.getElementById('scroll-down');
      cover_wrapper.id="none";
      cover_wrapper.style.display="none";
      scroll_down.style.display="none";
    
  
</script>
</pjax>
        </div>
        
  
  <footer class="footer clearfix"  itemscope itemtype="http://schema.org/WPFooter">
    <br><br>
    
      
        <div class="aplayer-container">
          


        </div>
      
    
      
        <br>
        <div class="social-wrapper" itemprop="about" itemscope itemtype="http://schema.org/Thing">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer" itemprop="url">
                
              </a>
            
          
            
              <a href="mailto:798145948@qq.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer" itemprop="url">
                
              </a>
            
          
            
              <a href="https://github.com/YuZhan-Hai"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer" itemprop="url">
                
              </a>
            
          
        </div>
      
    
      
        <div><p>Blog content follows the <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
      
    
      
        Use
        <a href="https://github.com/volantis-x/hexo-theme-volantis/#5.7.8" target="_blank" class="codename">Volantis</a>
        as theme
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2017-2021 XXX</a></p>

        </div>
      
    
    <!-- Custom Files footer begin-->
    
    <!-- Custom Files footer end-->
  </footer>


        <a id="s-top" class="fa-solid fa-arrow-up fa-fw" href="/" onclick="return false;" title="top"></a>
      </div>
    </div>
    <div>
      <script>
  /******************** volantis.dom ********************************/
  // 页面选择器 将dom对象缓存起来 see: /source/js/app.js etc.
  volantis.dom.bodyAnchor = volantis.dom.$(document.getElementById("safearea")); // 页面主体
  volantis.dom.topBtn = volantis.dom.$(document.getElementById('s-top')); // 向上
  volantis.dom.wrapper = volantis.dom.$(document.getElementById('wrapper')); // 整个导航栏
  volantis.dom.coverAnchor = volantis.dom.$(document.querySelector('#l_cover .cover-wrapper')); // 1个
  volantis.dom.switcher = volantis.dom.$(document.querySelector('#l_header .switcher .s-search')); // 搜索按钮   移动端 1个
  volantis.dom.header = volantis.dom.$(document.getElementById('l_header')); // 移动端导航栏
  volantis.dom.search = volantis.dom.$(document.querySelector('#l_header .m_search')); // 搜索框 桌面端 移动端 1个
  volantis.dom.mPhoneList = volantis.dom.$(document.querySelectorAll('#l_header .m-phone .list-v')); //  手机端 子菜单 多个
</script>

<script>
  
  volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fortawesome/fontawesome-free/css/all.min.css");
  
  
  
</script>

<!-- required -->


<!-- internal -->

<script src="/js/app.js"></script>






<!-- rightmenu要在darkmode之前（ToggleButton） darkmode要在comments之前（volantis.dark.push）-->



<script>
  function loadIssuesJS() {
    
      const sites_api = document.getElementById('sites-api');
      if (sites_api != undefined && typeof SitesJS === 'undefined') {
        volantis.js("/js/plugins/tags/sites.js")
      }
    
    
      const friends_api = document.getElementById('friends-api');
      if (friends_api != undefined && typeof FriendsJS === 'undefined') {
        volantis.js("/js/plugins/tags/friends.js")
      }
    
    
      const contributors_api = document.getElementById('contributors-api');
      if (contributors_api != undefined && typeof ContributorsJS === 'undefined') {
        volantis.js("/js/plugins/tags/contributors.js")
      }
    
  };
  loadIssuesJS()
  volantis.pjax.push(()=>{
    loadIssuesJS();
  })

</script>




  <script defer src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/vanilla-lazyload/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  

<script>
  window.FPConfig = {
	delay: 0,
	ignoreKeywords: ["#"],
	maxRPS: 6,
	hoverDelay: 0
  };
</script>
<script defer src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/flying-pages/flying-pages.min.js"></script>









      <script>
  volantis.layoutHelper("comments",`<div id="giscus_container"></div>`)

  volantis.giscus = {};

  function check_giscus() {
    if (volantis.dark.mode === "dark") {
      volantis.giscus.Theme = 'dark';
    } else {
      volantis.giscus.Theme = 'light';
    }

    return document.getElementById("giscus_container");
  }

  function pjax_giscus() {
    const HEAD = check_giscus();
    if (!HEAD) return;
    let cfg = Object.assign({"theme":{"light":"light","dark":"dark"}},pdata.commentConfig)
    const script = document.createElement('script');
    script.setAttribute('src', 'https://giscus.app/client.js');
    Object.keys(cfg).forEach(k=>{
      if (k != "theme") {
        script.setAttribute('data-'+k, cfg[k]);
      }
    })
    script.setAttribute('data-theme', volantis.giscus.Theme);
    script.setAttribute('crossorigin', "anonymous");
    HEAD.appendChild(script);
  }

  function dark_giscus() {
    const HEAD = check_giscus();
    if (!HEAD) return;

    const message = {
      setConfig: {
        theme: volantis.giscus.Theme
      }
    };
    const giscusIframe = document.querySelector('iframe.giscus-frame');
    giscusIframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
  }
  pjax_giscus();
  volantis.pjax.push(pjax_giscus);
  volantis.dark.push(dark_giscus);
</script>

    





<!-- optional -->

  <script>
  const SearchServiceDataPathRoot = ("/" || "/").endsWith("/") ?
    "/" || "/" :
    "//" || "/";
  const SearchServiceDataPath = SearchServiceDataPathRoot + "content.json";

  function loadSearchScript() {
    // see: layout/_partial/scripts/_ctrl/cdnCtrl.ejs
    return volantis.js("/js/search/hexo.js");
  }

  function loadSearchService() {
    loadSearchScript();
    document.querySelectorAll(".input.u-search-input").forEach((e) => {
      e.removeEventListener("focus", loadSearchService, false);
    });

    document.querySelectorAll(".u-search-form").forEach((e) => {
      e.addEventListener("submit", (event) => {
        event.preventDefault();
      }, false);
    });
  }

  // 打开并搜索 字符串 s
  function OpenSearch(s) {
    if (typeof SearchService === 'undefined')
      loadSearchScript().then(() => {
        SearchService.setQueryText(s);
        SearchService.search();
      });
    else {
      SearchService.setQueryText(s);
      SearchService.search();
    }
  }

  // 访问含有 ?s=xxx  的链接时打开搜索 // 与搜索引擎 structured data 相关: /scripts/helpers/structured-data/lib/config.js
  if (window.location.search && /^\?s=/g.test(window.location.search)) {
    let queryText = decodeURI(window.location.search)
      .replace(/\ /g, "-")
      .replace(/^\?s=/g, "");
    OpenSearch(queryText);
  }

  // 搜索输入框获取焦点时加载搜索
  document.querySelectorAll(".input.u-search-input").forEach((e) => {
    e.addEventListener("focus", loadSearchService, false);
  });
</script>







  <script>



  function pjax_highlightjs_copyCode(){
    if (!(document.querySelector(".highlight .code pre") ||
      document.querySelector(".article pre code"))) {
      return;
    }
    VolantisApp.utilCopyCode(".highlight .code pre, .article pre code")
  }
  volantis.requestAnimationFrame(pjax_highlightjs_copyCode)
  volantis.pjax.push(pjax_highlightjs_copyCode)

</script>












  <script>
  function load_swiper() {
    if (!document.querySelectorAll(".swiper-container")[0]) return;
    volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/swiper/swiper-bundle.min.css");
    volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/swiper/swiper-bundle.min.js").then(() => {
      pjax_swiper();
    });
  }

  load_swiper();

  function pjax_swiper() {
    volantis.swiper = new Swiper('.swiper-container', {
      slidesPerView: 'auto',
      spaceBetween: 8,
      centeredSlides: true,
      loop: true,
      pagination: {
        el: '.swiper-pagination',
        clickable: true,
      },
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-button-prev',
      },
    });
  }

  volantis.pjax.push(() => {
    if (!document.querySelectorAll(".swiper-container")[0]) return;
    if (typeof volantis.swiper === "undefined") {
      load_swiper();
    } else {
      pjax_swiper();
    }
  });
</script>


<!-- pjax 标签必须存在于所有页面 否则 pjax error -->
<pjax>

</pjax>

<script>
  function listennSidebarTOC() {
    const navItems = document.querySelectorAll(".toc li");
    if (!navItems.length) return;
    let targets = []
    const sections = [...navItems].map((element) => {
      const link = element.querySelector(".toc-link");
      const target = document.getElementById(
        decodeURI(link.getAttribute("href")).replace("#", "")
      );
      targets.push(target)
      // 解除 a 标签 href 的 锚点定位, a 标签 href 的 锚点定位 会随机启用?? 产生错位???
      link.setAttribute("onclick","return false;")
      link.setAttribute("toc-action","toc-"+decodeURI(link.getAttribute("href")).replace("#", ""))
      link.setAttribute("href","/")
      // 配置 点击 触发新的锚点定位
      link.addEventListener("click", (event) => {
        event.preventDefault();
        // 这里的 addTop 是通过错位使得 toc 自动展开.
        volantis.scroll.to(target,{addTop: 5, observer:true})
        // Anchor id
        history.pushState(null, document.title, "#" + target.id);
      });
      return target;
    });

    function activateNavByIndex(target) {
      if (target.classList.contains("active-current")) return;

      document.querySelectorAll(".toc .active").forEach((element) => {
        element.classList.remove("active", "active-current");
      });
      target.classList.add("active", "active-current");
      let parent = target.parentNode;
      while (!parent.matches(".toc")) {
        if (parent.matches("li")) parent.classList.add("active");
        parent = parent.parentNode;
      }
    }

    // 方案一：
    volantis.activateNavIndex=0
    activateNavByIndex(navItems[volantis.activateNavIndex])
    volantis.scroll.push(()=>{
      if (targets[0].getBoundingClientRect().top >= 0) {
        volantis.activateNavIndex = 0
      }else if (targets[targets.length-1].getBoundingClientRect().top < 0) {
        volantis.activateNavIndex = targets.length-1
      } else {
        for (let index = 0; index < targets.length; index++) {
          const target0 = targets[index];
          const target1 = targets[(index+1)%targets.length];
          if (target0.getBoundingClientRect().top < 0&&target1.getBoundingClientRect().top >= 0) {
            volantis.activateNavIndex=index
            break;
          }
        }
      }
      activateNavByIndex(navItems[volantis.activateNavIndex])
    })

    // 方案二：
    // IntersectionObserver 不是完美精确到像素级别 也不是低延时性的
    // function findIndex(entries) {
    //   let index = 0;
    //   let entry = entries[index];
    //   if (entry.boundingClientRect.top > 0) {
    //     index = sections.indexOf(entry.target);
    //     return index === 0 ? 0 : index - 1;
    //   }
    //   for (; index < entries.length; index++) {
    //     if (entries[index].boundingClientRect.top <= 0) {
    //       entry = entries[index];
    //     } else {
    //       return sections.indexOf(entry.target);
    //     }
    //   }
    //   return sections.indexOf(entry.target);
    // }
    // function createIntersectionObserver(marginTop) {
    //   marginTop = Math.floor(marginTop + 10000);
    //   let intersectionObserver = new IntersectionObserver(
    //     (entries, observe) => {
    //       let scrollHeight = document.documentElement.scrollHeight;
    //       if (scrollHeight > marginTop) {
    //         observe.disconnect();
    //         createIntersectionObserver(scrollHeight);
    //         return;
    //       }
    //       let index = findIndex(entries);
    //       activateNavByIndex(navItems[index]);
    //     }, {
    //       rootMargin: marginTop + "px 0px -100% 0px",
    //       threshold: 0,
    //     }
    //   );
    //   sections.forEach((element) => {
    //     element && intersectionObserver.observe(element);
    //   });
    // }
    // createIntersectionObserver(document.documentElement.scrollHeight);
  }

  document.addEventListener("DOMContentLoaded", ()=>{
    volantis.requestAnimationFrame(listennSidebarTOC)
  });
  document.addEventListener("pjax:success", ()=>{
    volantis.requestAnimationFrame(listennSidebarTOC)
  });
</script>



<script>
  document.onreadystatechange = function () {
    if (document.readyState == 'complete') {
      // 页面加载完毕 样式加载失败，或是当前网速慢，或是开启了省流模式
      const { saveData, effectiveType } = navigator.connection || navigator.mozConnection || navigator.webkitConnection || {}
      if (getComputedStyle(document.querySelector("#safearea"), null)["display"] == "none" || saveData || /2g/.test(effectiveType)) {
        document.querySelectorAll(".reveal").forEach(function (e) {
          e.style["opacity"] = "1";
        });
        document.querySelector("#safearea").style["display"] = "block";
      }
    }
  }
</script>


  <script type="application/ld+json">[{"@context":"http://schema.org","@type":"Organization","name":"Hexo","url":"http://example.com/","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},{"@context":"http://schema.org","@type":"Person","name":"John Doe","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"http://example.com/","sameAs":["https://github.com/volantis-x"],"description":"wode"},{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"http://example.com/","name":"Hexo"}},{"@type":"ListItem","position":3,"item":{"@id":"http://example.com/2023/08/04/汇编语言学习笔记/"}}]},{"@context":"http://schema.org","@type":"WebSite","name":"Hexo","url":"http://example.com/","keywords":null,"description":"wode","author":{"@type":"Person","name":"John Doe","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"http://example.com/","description":"wode"},"publisher":{"@type":"Organization","name":"Hexo","url":"http://example.com/","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},"potentialAction":{"@type":"SearchAction","name":"Site Search","target":{"@type":"EntryPoint","urlTemplate":"http://example.com?s={search_term_string}"},"query-input":"required name=search_term_string"}},{"@context":"http://schema.org","@type":"BlogPosting","description":"wode","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2023/08/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},"author":{"@type":"Person","name":"John Doe","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"http://example.com/"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},"url":"http://example.com/2023/08/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","wordCount":0,"datePublished":"2023-08-04T14:38:27.176Z","dateModified":"2023-08-04T15:03:02.361Z","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}}]</script>



      
        <!--
  pjax重载区域接口：
  1.  <pjax></pjax> 标签 pjax 标签必须存在于所有页面 否则 pjax error
  2.  script[data-pjax]
  3.  .pjax-reload script
  4.  .pjax
-->



<script src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/pjax/pjax.min.js"></script>


<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox]):not([onclick="return false;"]):not([onclick="return!1"]):not([target="_blank"]):not([target="view_window"]):not([href$=".xml"])',
        selectors: [
          "head title",
          "head meta[name=keywords]",
          "head meta[name=description]",
          
          "#l_main",
          "#pjax-header-nav-list",
          ".pjax",
          "pjax", // <pjax></pjax> 标签
          "script[data-pjax], .pjax-reload script" // script标签添加data-pjax 或 script标签外层添加.pjax-reload 的script代码段重载
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000,
        
      });
    });

    document.addEventListener('pjax:send', function (e) {
      //window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      // 使用 volantis.pjax.send 方法传入pjax:send回调函数 参见layout/_partial/scripts/global.ejs
      volantis.pjax.method.send.start();
    });

    document.addEventListener('pjax:complete', function () {
      // 使用 volantis.pjax.push 方法传入重载函数 参见layout/_partial/scripts/global.ejs
      volantis.pjax.method.complete.start();
    });

    document.addEventListener('pjax:error', function (e) {
      if(volantis.debug) {
        console.error(e);
        console.log('pjax error: \n' + JSON.stringify(e));
      }else{
        // 使用 volantis.pjax.error 方法传入pjax:error回调函数 参见layout/_partial/scripts/global.ejs
        volantis.pjax.method.error.start();
        window.location.href = e.triggerElement.href;
      }
    });
</script>

      
    </div>
    <!-- import body_end begin-->
    <!-- import body_end end-->
    <!-- Custom Files bodyEnd begin-->
    
    <!-- Custom Files bodyEnd end-->
  </body>
</html>
